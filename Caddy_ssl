#!/bin/bash

# Caddy SSL 自动配置脚本 v3.0
# 支持自定义端口、配置管理、自动处理端口冲突

set -e

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# 打印带颜色的消息
print_info() {
    echo -e "${BLUE}[信息]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[成功]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[警告]${NC} $1"
}

print_error() {
    echo -e "${RED}[错误]${NC} $1"
}

print_title() {
    echo -e "${CYAN}$1${NC}"
}

# 检查是否为 root 用户
check_root() {
    if [ "$EUID" -ne 0 ]; then 
        print_error "请使用 root 权限运行此脚本"
        echo "使用: sudo bash $0"
        exit 1
    fi
}

# 检测端口占用情况
check_port_usage() {
    local port=$1
    local process_info=$(ss -tulnp 2>/dev/null | grep ":$port " | head -n 1)
    
    if [ ! -z "$process_info" ]; then
        echo "$process_info"
        return 1
    fi
    return 0
}

# 智能处理端口冲突
handle_port_conflict() {
    local port=$1
    local port_name=$2
    
    local process_info=$(ss -tulnp 2>/dev/null | grep ":$port " | head -n 1)
    
    if [ -z "$process_info" ]; then
        return 0  # 端口未被占用
    fi
    
    # 提取进程信息
    local process_name=$(echo "$process_info" | grep -oP 'users:\(\(".*?",pid=\d+' | grep -oP '"\K[^"]+' | head -n 1 2>/dev/null || echo "unknown")
    local pid=$(echo "$process_info" | grep -oP 'pid=\K\d+' | head -n 1 2>/dev/null || echo "unknown")
    
    print_warning "端口 $port ($port_name) 已被占用"
    echo "进程: $process_name (PID: $pid)"
    echo ""
    echo "请选择处理方式:"
    echo "1) 停止占用端口的服务"
    echo "2) 使用其他端口 (Caddy 将使用 HTTP: 81, HTTPS: 8443)"
    echo "3) 尝试修改占用服务的端口配置"
    echo "4) 退出"
    echo ""
    read -r -p "请选择 [1-4]: " choice
    
    case $choice in
        1)
            print_info "正在停止进程 $pid..."
            kill -9 $pid 2>/dev/null || true
            
            # 如果是 systemd 服务，也禁用它
            if systemctl is-active --quiet $process_name 2>/dev/null; then
                systemctl stop $process_name 2>/dev/null || true
                read -r -p "是否禁用该服务开机自启? (y/n): " disable_service
                if [[ $disable_service == "y" || $disable_service == "Y" ]]; then
                    systemctl disable $process_name 2>/dev/null || true
                fi
            fi
            
            sleep 2
            print_success "进程已停止"
            return 0
            ;;
        2)
            print_info "将使用备用端口配置"
            return 2
            ;;
        3)
            attempt_modify_service_port "$process_name" "$port"
            return $?
            ;;
        4)
            print_info "退出安装"
            exit 0
            ;;
        *)
            print_error "无效选择"
            return 1
            ;;
    esac
}

# 尝试修改常见服务的端口配置
attempt_modify_service_port() {
    local service_name=$1
    local old_port=$2
    local new_port=8080
    
    print_info "尝试修改 $service_name 的端口配置..."
    
    case $service_name in
        nginx)
            if [ -f /etc/nginx/nginx.conf ]; then
                print_warning "检测到 Nginx 配置文件"
                read -r -p "是否将 Nginx 端口改为 $new_port? (y/n): " modify
                if [[ $modify == "y" || $modify == "Y" ]]; then
                    sed -i "s/listen[[:space:]]*80/listen $new_port/g" /etc/nginx/nginx.conf
                    sed -i "s/listen[[:space:]]*80/listen $new_port/g" /etc/nginx/sites-enabled/* 2>/dev/null || true
                    systemctl restart nginx
                    print_success "Nginx 端口已修改为 $new_port"
                    return 0
                fi
            fi
            ;;
        apache2|httpd)
            if [ -f /etc/apache2/ports.conf ]; then
                print_warning "检测到 Apache 配置文件"
                read -r -p "是否将 Apache 端口改为 $new_port? (y/n): " modify
                if [[ $modify == "y" || $modify == "Y" ]]; then
                    sed -i "s/Listen 80/Listen $new_port/g" /etc/apache2/ports.conf
                    systemctl restart apache2
                    print_success "Apache 端口已修改为 $new_port"
                    return 0
                fi
            fi
            ;;
        xray*|v2ray*)
            # 查找 xray/v2ray 配置文件
            local config_files=$(find /etc /usr/local/etc -name "config.json" 2>/dev/null | grep -E "xray|v2ray" | head -n 1)
            if [ ! -z "$config_files" ]; then
                print_warning "检测到 $service_name 配置: $config_files"
                read -r -p "是否将端口改为 $new_port? (y/n): " modify
                if [[ $modify == "y" || $modify == "Y" ]]; then
                    # 备份配置
                    cp "$config_files" "$config_files.backup.$(date +%Y%m%d_%H%M%S)"
                    # 修改端口
                    sed -i "s/\"port\":[[:space:]]*$old_port/\"port\": $new_port/g" "$config_files"
                    systemctl restart $service_name 2>/dev/null || true
                    print_success "$service_name 端口已修改为 $new_port"
                    print_info "原配置已备份"
                    return 0
                fi
            fi
            ;;
    esac
    
    print_warning "无法自动修改端口，请手动处理"
    return 1
}

# 卸载 Nginx
remove_nginx() {
    if systemctl is-active --quiet nginx 2>/dev/null || [ -d "/etc/nginx" ]; then
        print_warning "检测到 Nginx 已安装"
        read -r -p "是否卸载 Nginx? (y/n): " remove_nginx_choice
        
        if [[ $remove_nginx_choice == "y" || $remove_nginx_choice == "Y" ]]; then
            print_info "正在卸载 Nginx..."
            systemctl stop nginx 2>/dev/null || true
            systemctl disable nginx 2>/dev/null || true
            apt-get remove --purge nginx nginx-common nginx-full -y 2>/dev/null || true
            rm -rf /etc/nginx
            rm -rf /var/log/nginx
            rm -rf /www/server/nginx
            print_success "Nginx 已卸载"
        fi
    fi
}

# 安装 Caddy
install_caddy() {
    if command -v caddy &> /dev/null; then
        print_success "Caddy 已安装，版本: $(caddy version)"
        read -r -p "是否重新安装? (y/n): " reinstall
        
        if [[ $reinstall != "y" && $reinstall != "Y" ]]; then
            return 0
        fi
    fi
    
    print_info "正在安装 Caddy..."
    
    # 安装依赖
    apt-get update -qq
    apt-get install -y -qq debian-keyring debian-archive-keyring apt-transport-https curl > /dev/null 2>&1
    
    # 添加 Caddy 仓库
    curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/gpg.key' 2>/dev/null | gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg
    curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt' 2>/dev/null | tee /etc/apt/sources.list.d/caddy-stable.list > /dev/null
    
    # 安装 Caddy
    apt-get update -qq
    apt-get install -y -qq caddy > /dev/null 2>&1
    
    print_success "Caddy 安装完成"
}

# 验证域名 DNS 解析
check_dns() {
    local domain=$1
    print_info "正在检查域名 DNS 解析..."
    
    local server_ip=$(curl -s --max-time 5 ifconfig.me 2>/dev/null || curl -s --max-time 5 icanhazip.com 2>/dev/null || curl -s --max-time 5 ipinfo.io/ip 2>/dev/null)
    local domain_ip=$(dig +short $domain 2>/dev/null | tail -n1)
    
    if [ -z "$domain_ip" ]; then
        print_warning "无法解析域名 $domain"
        print_warning "请确保域名 DNS 已正确配置指向: $server_ip"
        read -r -p "是否继续? (y/n): " continue_anyway
        if [[ $continue_anyway != "y" && $continue_anyway != "Y" ]]; then
            return 1
        fi
    elif [ "$domain_ip" != "$server_ip" ]; then
        print_warning "域名解析到: $domain_ip"
        print_warning "但服务器 IP 是: $server_ip"
        print_warning "HTTPS 证书申请可能失败"
        read -r -p "是否继续? (y/n): " continue_anyway
        if [[ $continue_anyway != "y" && $continue_anyway != "Y" ]]; then
            return 1
        fi
    else
        print_success "DNS 解析正确: $domain -> $server_ip"
    fi
    return 0
}

# 生成 Caddy 配置
generate_site_config() {
    local domain=$1
    local backend_port=$2
    
    cat <<EOF

$domain {
    reverse_proxy localhost:$backend_port
    
    log {
        output file /var/log/caddy/${domain}.log
    }
    
    header {
        Strict-Transport-Security "max-age=31536000; includeSubDomains; preload"
        X-Content-Type-Options "nosniff"
        X-Frame-Options "DENY"
        Referrer-Policy "no-referrer-when-downgrade"
    }
}
EOF
}

# 配置 Caddy
configure_caddy() {
    local domain=$1
    local backend_port=$2
    local http_port=$3
    local https_port=$4
    local append=$5
    
    print_info "正在配置 Caddy..."
    
    # 备份现有配置
    if [ -f /etc/caddy/Caddyfile ] && [ "$append" != "true" ]; then
        cp /etc/caddy/Caddyfile /etc/caddy/Caddyfile.backup.$(date +%Y%m%d_%H%M%S)
    fi
    
    # 创建或追加配置
    if [ "$append" == "true" ] && [ -f /etc/caddy/Caddyfile ]; then
        # 追加模式
        generate_site_config "$domain" "$backend_port" >> /etc/caddy/Caddyfile
        print_success "配置已追加到 /etc/caddy/Caddyfile"
    else
        # 新建配置
        if [ "$http_port" == "80" ] && [ "$https_port" == "443" ]; then
            cat > /etc/caddy/Caddyfile <<EOF
# Caddy 配置文件
# 自动生成时间: $(date)
$(generate_site_config "$domain" "$backend_port")
EOF
        else
            cat > /etc/caddy/Caddyfile <<EOF
# Caddy 配置文件 (自定义端口)
# 自动生成时间: $(date)

{
    http_port $http_port
    https_port $https_port
}
$(generate_site_config "$domain" "$backend_port")
EOF
        fi
        print_success "配置文件已创建: /etc/caddy/Caddyfile"
    fi
}

# 重新加载 Caddy
reload_caddy() {
    print_info "正在验证配置..."
    
    if caddy validate --config /etc/caddy/Caddyfile 2>&1; then
        print_success "配置验证通过"
    else
        print_error "配置验证失败"
        return 1
    fi
    
    print_info "正在重新加载 Caddy..."
    systemctl reload caddy 2>/dev/null || systemctl restart caddy
    
    sleep 2
    
    if systemctl is-active --quiet caddy; then
        print_success "Caddy 重新加载成功"
    else
        print_error "Caddy 重新加载失败"
        print_info "查看日志: journalctl -u caddy -n 50"
        return 1
    fi
    return 0
}

# 启动 Caddy
start_caddy() {
    print_info "正在验证配置..."
    
    if caddy validate --config /etc/caddy/Caddyfile 2>&1; then
        print_success "配置验证通过"
    else
        print_error "配置验证失败"
        return 1
    fi
    
    print_info "正在启动 Caddy..."
    systemctl enable caddy 2>/dev/null
    systemctl restart caddy
    
    sleep 3
    
    if systemctl is-active --quiet caddy; then
        print_success "Caddy 启动成功"
    else
        print_error "Caddy 启动失败"
        print_info "查看日志: journalctl -u caddy -n 50"
        return 1
    fi
    return 0
}

# 列出所有配置的站点
list_sites() {
    if [ ! -f /etc/caddy/Caddyfile ]; then
        print_warning "未找到 Caddy 配置文件"
        return
    fi
    
    echo ""
    print_title "===== 当前配置的站点 ====="
    echo ""
    
    # 提取所有域名配置
    grep -E "^[a-zA-Z0-9].*\{$" /etc/caddy/Caddyfile | sed 's/ {$//' | nl -w2 -s'. '
    
    echo ""
}

# 添加新站点
add_site() {
    echo ""
    print_title "===== 添加新站点 ====="
    echo ""
    
    read -r -p "域名 (例如: example.com): " domain
    if [ -z "$domain" ]; then
        print_error "域名不能为空"
        return 1
    fi
    
    read -r -p "后端服务端口 (例如: 3000): " backend_port
    if [ -z "$backend_port" ]; then
        print_error "端口不能为空"
        return 1
    fi
    
    if ! [[ "$backend_port" =~ ^[0-9]+$ ]]; then
        print_error "端口必须是数字"
        return 1
    fi
    
    # 检查域名是否已存在
    if grep -q "^$domain" /etc/caddy/Caddyfile 2>/dev/null; then
        print_error "域名 $domain 已存在"
        return 1
    fi
    
    check_dns "$domain" || return 1
    
    configure_caddy "$domain" "$backend_port" "80" "443" "true"
    
    if reload_caddy; then
        print_success "站点添加成功: https://$domain"
    else
        print_error "配置重载失败"
        return 1
    fi
}

# 删除站点
remove_site() {
    list_sites
    
    if [ ! -f /etc/caddy/Caddyfile ]; then
        return
    fi
    
    echo ""
    read -r -p "请输入要删除的域名: " domain
    
    if [ -z "$domain" ]; then
        print_error "域名不能为空"
        return 1
    fi
    
    if ! grep -q "^$domain" /etc/caddy/Caddyfile; then
        print_error "未找到域名 $domain"
        return 1
    fi
    
    # 备份配置
    cp /etc/caddy/Caddyfile /etc/caddy/Caddyfile.backup.$(date +%Y%m%d_%H%M%S)
    
    # 删除站点配置 (包括域名行到对应的闭合括号)
    sed -i "/^$domain {$/,/^}$/d" /etc/caddy/Caddyfile
    
    if reload_caddy; then
        print_success "站点已删除: $domain"
    else
        print_error "配置重载失败，已恢复备份"
        return 1
    fi
}

# 编辑配置文件
edit_config() {
    if [ ! -f /etc/caddy/Caddyfile ]; then
        print_error "配置文件不存在"
        return 1
    fi
    
    # 备份配置
    cp /etc/caddy/Caddyfile /etc/caddy/Caddyfile.backup.$(date +%Y%m%d_%H%M%S)
    
    # 选择编辑器
    if command -v nano &> /dev/null; then
        nano /etc/caddy/Caddyfile
    elif command -v vim &> /dev/null; then
        vim /etc/caddy/Caddyfile
    else
        vi /etc/caddy/Caddyfile
    fi
    
    # 验证配置
    if caddy validate --config /etc/caddy/Caddyfile 2>&1; then
        print_success "配置验证通过"
        read -r -p "是否重新加载配置? (y/n): " reload
        if [[ $reload == "y" || $reload == "Y" ]]; then
            reload_caddy
        fi
    else
        print_error "配置验证失败"
        read -r -p "是否恢复备份? (y/n): " restore
        if [[ $restore == "y" || $restore == "Y" ]]; then
            mv /etc/caddy/Caddyfile.backup.$(date +%Y%m%d)* /etc/caddy/Caddyfile
            print_success "已恢复备份"
        fi
    fi
}

# 查看状态
show_status() {
    echo ""
    print_title "===== Caddy 状态 ====="
    echo ""
    systemctl status caddy --no-pager -l
    echo ""
    
    print_title "===== 最近日志 ====="
    echo ""
    journalctl -u caddy -n 20 --no-pager
}

# 配置管理菜单
manage_menu() {
    while true; do
        clear
        echo ""
        print_title "================================================"
        print_title "         Caddy 配置管理"
        print_title "================================================"
        echo ""
        echo "1) 查看所有站点"
        echo "2) 添加新站点"
        echo "3) 删除站点"
        echo "4) 编辑配置文件"
        echo "5) 查看 Caddy 状态和日志"
        echo "6) 重新加载配置"
        echo "7) 重启 Caddy"
        echo "0) 退出"
        echo ""
        read -r -p "请选择 [0-7]: " choice
        
        case $choice in
            1)
                list_sites
                read -r -p "按回车继续..."
                ;;
            2)
                add_site
                read -r -p "按回车继续..."
                ;;
            3)
                remove_site
                read -r -p "按回车继续..."
                ;;
            4)
                edit_config
                read -r -p "按回车继续..."
                ;;
            5)
                show_status
                read -r -p "按回车继续..."
                ;;
            6)
                reload_caddy
                read -r -p "按回车继续..."
                ;;
            7)
                systemctl restart caddy
                print_success "Caddy 已重启"
                read -r -p "按回车继续..."
                ;;
            0)
                print_info "退出管理菜单"
                break
                ;;
            *)
                print_error "无效选择"
                sleep 1
                ;;
        esac
    done
}

# 显示结果
show_result() {
    local domain=$1
    local backend_port=$2
    local http_port=$3
    local https_port=$4
    
    echo ""
    echo "================================================"
    print_success "配置完成！"
    echo "================================================"
    echo ""
    
    if [ "$https_port" == "443" ]; then
        echo "访问地址: https://$domain"
    else
        echo "访问地址: https://$domain:$https_port"
    fi
    
    echo "后端端口: $backend_port"
    echo "Caddy HTTP 端口: $http_port"
    echo "Caddy HTTPS 端口: $https_port"
    echo ""
    echo "常用命令:"
    echo "  查看状态: sudo systemctl status caddy"
    echo "  查看日志: sudo journalctl -u caddy -f"
    echo "  重启服务: sudo systemctl restart caddy"
    echo "  重载配置: sudo systemctl reload caddy"
    echo "  配置管理: sudo bash $0 manage"
    echo ""
    echo "配置文件: /etc/caddy/Caddyfile"
    echo "日志位置: /var/log/caddy/"
    echo ""
    
    if [ "$https_port" != "443" ]; then
        print_warning "使用非标准端口，Let's Encrypt 证书申请可能失败"
        print_info "建议: 解决端口冲突后改用标准端口"
    else
        print_info "SSL 证书会在首次访问时自动申请"
    fi
    
    echo ""
}

# 初始安装流程
initial_setup() {
    clear
    echo "================================================"
    print_title "    Caddy SSL 自动配置脚本 v3.0"
    print_title "    自动 HTTPS + 反向代理 + 配置管理"
    echo "================================================"
    echo ""
    
    check_root
    remove_nginx
    install_caddy
    
    # 创建日志目录
    mkdir -p /var/log/caddy
    
    # 检查端口占用
    print_info "检查端口占用情况..."
    
    local use_alt_ports=0
    
    # 检查 80 端口
    if ! check_port_usage 80 > /dev/null 2>&1; then
        handle_port_conflict 80 "HTTP"
        local result=$?
        if [ $result -eq 2 ]; then
            use_alt_ports=1
        elif [ $result -ne 0 ]; then
            print_error "无法处理端口冲突"
            exit 1
        fi
    fi
    
    # 检查 443 端口
    if [ $use_alt_ports -eq 0 ]; then
        if ! check_port_usage 443 > /dev/null 2>&1; then
            handle_port_conflict 443 "HTTPS"
            local result=$?
            if [ $result -eq 2 ]; then
                use_alt_ports=1
            elif [ $result -ne 0 ]; then
                print_error "无法处理端口冲突"
                exit 1
            fi
        fi
    fi
    
    # 设置端口
    local http_port=80
    local https_port=443
    
    if [ $use_alt_ports -eq 1 ]; then
        http_port=81
        https_port=8443
        print_info "使用备用端口: HTTP=$http_port, HTTPS=$https_port"
    fi
    
    # 配置第一个站点
    echo ""
    print_title "===== 配置第一个站点 ====="
    echo ""
    
    read -r -p "域名 (例如: vps1.chf5762.cloudns.org): " domain
    if [ -z "$domain" ]; then
        print_error "域名不能为空"
        exit 1
    fi
    
    read -r -p "后端服务端口 (例如: 4444): " backend_port
    if [ -z "$backend_port" ]; then
        print_error "端口不能为空"
        exit 1
    fi
    
    if ! [[ "$backend_port" =~ ^[0-9]+$ ]]; then
        print_error "端口必须是数字"
        exit 1
    fi
    
    check_dns "$domain" || exit 1
    
    configure_caddy "$domain" "$backend_port" "$http_port" "$https_port" "false"
    
    if ! start_caddy; then
        print_error "Caddy 启动失败"
        exit 1
    fi
    
    show_result "$domain" "$backend_port" "$http_port" "$https_port"
    
    # 询问是否进入管理菜单
    read -r -p "是否进入配置管理菜单? (y/n): " enter_menu
    if [[ $enter_menu == "y" || $enter_menu == "Y" ]]; then
        manage_menu
    fi
    
    echo ""
    print_success "安装完成！下次运行 'sudo bash $0 manage' 可进入配置管理"
    echo ""
}

# 主函数
main() {
    # 检查参数
    if [ "$1" == "manage" ] || [ "$1" == "m" ]; then
        check_root
        if [ ! -f /etc/caddy/Caddyfile ]; then
            print_error "Caddy 未安装或配置文件不存在"
            print_info "请先运行: sudo bash $0"
            exit 1
        fi
        manage_menu
    else
        initial_setup
    fi
}

# 运行主函数
main "$@"
