#!/bin/bash

# Caddy SSL 自动配置脚本 v2.0
# 支持自定义端口，自动处理端口冲突

set -e

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 打印带颜色的消息
print_info() {
    echo -e "${BLUE}[信息]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[成功]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[警告]${NC} $1"
}

print_error() {
    echo -e "${RED}[错误]${NC} $1"
}

# 检查是否为 root 用户
check_root() {
    if [ "$EUID" -ne 0 ]; then 
        print_error "请使用 root 权限运行此脚本"
        echo "使用: sudo bash $0"
        exit 1
    fi
}

# 检测端口占用情况
check_port_usage() {
    local port=$1
    local process_info=$(ss -tulnp | grep ":$port " | head -n 1)
    
    if [ ! -z "$process_info" ]; then
        echo "$process_info"
        return 1
    fi
    return 0
}

# 智能处理端口冲突
handle_port_conflict() {
    local port=$1
    local port_name=$2
    
    local process_info=$(ss -tulnp | grep ":$port " | head -n 1)
    
    if [ -z "$process_info" ]; then
        return 0  # 端口未被占用
    fi
    
    # 提取进程信息
    local process_name=$(echo "$process_info" | grep -oP 'users:\(\(".*?",pid=\d+' | grep -oP '"\K[^"]+' | head -n 1)
    local pid=$(echo "$process_info" | grep -oP 'pid=\K\d+' | head -n 1)
    
    print_warning "端口 $port ($port_name) 已被占用"
    echo "进程: $process_name (PID: $pid)"
    echo ""
    echo "请选择处理方式:"
    echo "1) 停止占用端口的服务"
    echo "2) 使用其他端口 (Caddy 将使用 HTTP: 81, HTTPS: 8443)"
    echo "3) 尝试修改占用服务的端口配置"
    echo "4) 退出"
    echo ""
    echo -n "请选择 [1-4]: "
    read -r choice
    
    case $choice in
        1)
            print_info "正在停止进程 $pid..."
            kill -9 $pid 2>/dev/null || true
            
            # 如果是 systemd 服务，也禁用它
            if systemctl is-active --quiet $process_name 2>/dev/null; then
                systemctl stop $process_name 2>/dev/null || true
                echo -n "是否禁用该服务开机自启? (y/n): "
                read -r disable_service
                if [[ $disable_service == "y" || $disable_service == "Y" ]]; then
                    systemctl disable $process_name 2>/dev/null || true
                fi
            fi
            
            sleep 2
            print_success "进程已停止"
            return 0
            ;;
        2)
            print_info "将使用备用端口配置"
            return 2
            ;;
        3)
            attempt_modify_service_port "$process_name" "$port"
            return $?
            ;;
        4)
            print_info "退出安装"
            exit 0
            ;;
        *)
            print_error "无效选择"
            return 1
            ;;
    esac
}

# 尝试修改常见服务的端口配置
attempt_modify_service_port() {
    local service_name=$1
    local old_port=$2
    local new_port=8080
    
    print_info "尝试修改 $service_name 的端口配置..."
    
    case $service_name in
        nginx)
            if [ -f /etc/nginx/nginx.conf ]; then
                print_warning "检测到 Nginx 配置文件"
                echo -n "是否将 Nginx 端口改为 $new_port? (y/n): "
                read -r modify
                if [[ $modify == "y" || $modify == "Y" ]]; then
                    sed -i "s/listen[[:space:]]*80/listen $new_port/g" /etc/nginx/nginx.conf
                    sed -i "s/listen[[:space:]]*80/listen $new_port/g" /etc/nginx/sites-enabled/* 2>/dev/null || true
                    systemctl restart nginx
                    print_success "Nginx 端口已修改为 $new_port"
                    return 0
                fi
            fi
            ;;
        apache2|httpd)
            if [ -f /etc/apache2/ports.conf ]; then
                print_warning "检测到 Apache 配置文件"
                echo -n "是否将 Apache 端口改为 $new_port? (y/n): "
                read -r modify
                if [[ $modify == "y" || $modify == "Y" ]]; then
                    sed -i "s/Listen 80/Listen $new_port/g" /etc/apache2/ports.conf
                    systemctl restart apache2
                    print_success "Apache 端口已修改为 $new_port"
                    return 0
                fi
            fi
            ;;
        xray*|v2ray*)
            # 查找 xray/v2ray 配置文件
            local config_files=$(find /etc /usr/local/etc -name "config.json" 2>/dev/null | grep -E "xray|v2ray" | head -n 1)
            if [ ! -z "$config_files" ]; then
                print_warning "检测到 $service_name 配置: $config_files"
                echo -n "是否将端口改为 $new_port? (y/n): "
                read -r modify
                if [[ $modify == "y" || $modify == "Y" ]]; then
                    # 备份配置
                    cp "$config_files" "$config_files.backup.$(date +%Y%m%d_%H%M%S)"
                    # 修改端口
                    sed -i "s/\"port\":[[:space:]]*$old_port/\"port\": $new_port/g" "$config_files"
                    systemctl restart $service_name 2>/dev/null || true
                    print_success "$service_name 端口已修改为 $new_port"
                    print_info "原配置已备份"
                    return 0
                fi
            fi
            ;;
    esac
    
    print_warning "无法自动修改端口，请手动处理"
    return 1
}

# 卸载 Nginx
remove_nginx() {
    if systemctl is-active --quiet nginx 2>/dev/null || [ -d "/etc/nginx" ]; then
        print_warning "检测到 Nginx 已安装"
        echo -n "是否卸载 Nginx? (y/n): "
        read -r remove_nginx_choice
        
        if [[ $remove_nginx_choice == "y" || $remove_nginx_choice == "Y" ]]; then
            print_info "正在卸载 Nginx..."
            systemctl stop nginx 2>/dev/null || true
            systemctl disable nginx 2>/dev/null || true
            apt-get remove --purge nginx nginx-common nginx-full -y 2>/dev/null || true
            rm -rf /etc/nginx
            rm -rf /var/log/nginx
            rm -rf /www/server/nginx
            print_success "Nginx 已卸载"
        fi
    fi
}

# 安装 Caddy
install_caddy() {
    if command -v caddy &> /dev/null; then
        print_success "Caddy 已安装，版本: $(caddy version)"
        echo -n "是否重新安装? (y/n): "
        read -r reinstall
        
        if [[ $reinstall != "y" && $reinstall != "Y" ]]; then
            return 0
        fi
    fi
    
    print_info "正在安装 Caddy..."
    
    # 安装依赖
    apt-get update
    apt-get install -y debian-keyring debian-archive-keyring apt-transport-https curl
    
    # 添加 Caddy 仓库
    curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/gpg.key' | gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg
    curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt' | tee /etc/apt/sources.list.d/caddy-stable.list
    
    # 安装 Caddy
    apt-get update
    apt-get install -y caddy
    
    print_success "Caddy 安装完成"
}

# 验证域名 DNS 解析
check_dns() {
    local domain=$1
    print_info "正在检查域名 DNS 解析..."
    
    local server_ip=$(curl -s ifconfig.me || curl -s icanhazip.com || curl -s ipinfo.io/ip)
    local domain_ip=$(dig +short $domain | tail -n1)
    
    if [ -z "$domain_ip" ]; then
        print_warning "无法解析域名 $domain"
        print_warning "请确保域名 DNS 已正确配置指向: $server_ip"
        echo -n "是否继续? (y/n): "
        read -r continue_anyway
        if [[ $continue_anyway != "y" && $continue_anyway != "Y" ]]; then
            exit 1
        fi
    elif [ "$domain_ip" != "$server_ip" ]; then
        print_warning "域名解析到: $domain_ip"
        print_warning "但服务器 IP 是: $server_ip"
        print_warning "HTTPS 证书申请可能失败"
        echo -n "是否继续? (y/n): "
        read -r continue_anyway
        if [[ $continue_anyway != "y" && $continue_anyway != "Y" ]]; then
            exit 1
        fi
    else
        print_success "DNS 解析正确: $domain -> $server_ip"
    fi
}

# 配置 Caddy (支持自定义端口)
configure_caddy() {
    local domain=$1
    local backend_port=$2
    local http_port=$3
    local https_port=$4
    
    print_info "正在配置 Caddy..."
    
    # 备份现有配置
    if [ -f /etc/caddy/Caddyfile ]; then
        cp /etc/caddy/Caddyfile /etc/caddy/Caddyfile.backup.$(date +%Y%m%d_%H%M%S)
    fi
    
    # 创建新配置
    if [ "$http_port" == "80" ] && [ "$https_port" == "443" ]; then
        # 标准端口配置
        cat > /etc/caddy/Caddyfile <<EOF
# Caddy 配置文件
# 自动生成时间: $(date)

$domain {
    reverse_proxy localhost:$backend_port
    
    # 日志
    log {
        output file /var/log/caddy/$domain.log
    }
    
    # 安全头
    header {
        Strict-Transport-Security "max-age=31536000; includeSubDomains; preload"
        X-Content-Type-Options "nosniff"
        X-Frame-Options "DENY"
        Referrer-Policy "no-referrer-when-downgrade"
    }
}
EOF
    else
        # 自定义端口配置
        cat > /etc/caddy/Caddyfile <<EOF
# Caddy 配置文件 (自定义端口)
# 自动生成时间: $(date)

{
    # 全局选项
    http_port $http_port
    https_port $https_port
}

$domain {
    reverse_proxy localhost:$backend_port
    
    # 日志
    log {
        output file /var/log/caddy/$domain.log
    }
    
    # 安全头
    header {
        Strict-Transport-Security "max-age=31536000; includeSubDomains; preload"
        X-Content-Type-Options "nosniff"
        X-Frame-Options "DENY"
        Referrer-Policy "no-referrer-when-downgrade"
    }
}
EOF
        print_warning "注意: Caddy 使用非标准端口"
        print_warning "HTTP: $http_port, HTTPS: $https_port"
        print_warning "访问时需要加端口号: https://$domain:$https_port"
    fi

    print_success "配置文件已创建: /etc/caddy/Caddyfile"
}

# 测试并启动 Caddy
start_caddy() {
    print_info "正在验证配置..."
    
    if caddy validate --config /etc/caddy/Caddyfile; then
        print_success "配置验证通过"
    else
        print_error "配置验证失败"
        exit 1
    fi
    
    print_info "正在启动 Caddy..."
    systemctl enable caddy
    systemctl restart caddy
    
    sleep 3
    
    if systemctl is-active --quiet caddy; then
        print_success "Caddy 启动成功"
    else
        print_error "Caddy 启动失败"
        print_info "查看日志: journalctl -u caddy -n 50"
        exit 1
    fi
}

# 显示结果
show_result() {
    local domain=$1
    local backend_port=$2
    local http_port=$3
    local https_port=$4
    
    echo ""
    echo "================================================"
    print_success "配置完成！"
    echo "================================================"
    echo ""
    
    if [ "$https_port" == "443" ]; then
        echo "访问地址: https://$domain"
    else
        echo "访问地址: https://$domain:$https_port"
    fi
    
    echo "后端端口: $backend_port"
    echo "Caddy HTTP 端口: $http_port"
    echo "Caddy HTTPS 端口: $https_port"
    echo ""
    echo "常用命令:"
    echo "  查看状态: sudo systemctl status caddy"
    echo "  查看日志: sudo journalctl -u caddy -f"
    echo "  重启服务: sudo systemctl restart caddy"
    echo "  编辑配置: sudo nano /etc/caddy/Caddyfile"
    echo "  重载配置: sudo systemctl reload caddy"
    echo ""
    echo "配置文件位置: /etc/caddy/Caddyfile"
    echo "日志位置: /var/log/caddy/$domain.log"
    echo ""
    
    if [ "$https_port" != "443" ]; then
        print_warning "由于使用非标准端口，SSL 证书申请可能失败"
        print_warning "Let's Encrypt 需要通过标准端口 (80/443) 验证域名"
        print_info "建议: 解决端口冲突后改用标准端口"
    else
        print_info "SSL 证书会在首次访问时自动申请，请稍等片刻"
    fi
    
    echo ""
}

# 主函数
main() {
    clear
    echo "================================================"
    echo "    Caddy SSL 自动配置脚本 v2.0"
    echo "    自动 HTTPS + 反向代理 + 智能端口处理"
    echo "================================================"
    echo ""
    
    check_root
    remove_nginx
    install_caddy
    
    # 创建日志目录
    mkdir -p /var/log/caddy
    
    # 检查端口占用情况
    print_info "检查端口占用情况..."
    
    local use_alt_ports=0
    
    # 检查 80 端口
    if ! check_port_usage 80 > /dev/null 2>&1; then
        handle_port_conflict 80 "HTTP"
        local result=$?
        if [ $result -eq 2 ]; then
            use_alt_ports=1
        elif [ $result -ne 0 ]; then
            print_error "无法处理端口冲突"
            exit 1
        fi
    fi
    
    # 检查 443 端口
    if [ $use_alt_ports -eq 0 ]; then
        if ! check_port_usage 443 > /dev/null 2>&1; then
            handle_port_conflict 443 "HTTPS"
            local result=$?
            if [ $result -eq 2 ]; then
                use_alt_ports=1
            elif [ $result -ne 0 ]; then
                print_error "无法处理端口冲突"
                exit 1
            fi
        fi
    fi
    
    # 设置端口
    local http_port=80
    local https_port=443
    
    if [ $use_alt_ports -eq 1 ]; then
        http_port=81
        https_port=8443
        print_info "使用备用端口: HTTP=$http_port, HTTPS=$https_port"
    fi
    
    while true; do
        echo ""
        echo "请输入配置信息:"
        echo ""
        
        # 输入域名
        read -p "域名 (例如: vps1.chf5762.cloudns.org): " domain
        if [ -z "$domain" ]; then
            print_error "域名不能为空"
            continue
        fi
        
        # 输入端口
        read -p "后端服务端口 (例如: 4444): " backend_port
        if [ -z "$backend_port" ]; then
            print_error "端口不能为空"
            continue
        fi
        
        # 验证端口是否为数字
        if ! [[ "$backend_port" =~ ^[0-9]+$ ]]; then
            print_error "端口必须是数字"
            continue
        fi
        
        # 检查 DNS
        check_dns "$domain"
        
        # 配置 Caddy
        configure_caddy "$domain" "$backend_port" "$http_port" "$https_port"
        
        # 启动服务
        start_caddy
        
        # 显示结果
        show_result "$domain" "$backend_port" "$http_port" "$https_port"
        
        # 询问是否添加更多站点
        echo ""
        echo -n "是否继续添加其他域名? (y/n): "
        read -r add_more
        
        if [[ $add_more != "y" && $add_more != "Y" ]]; then
            break
        fi
        
        # 如果要添加更多站点，追加到配置文件
        echo "" >> /etc/caddy/Caddyfile
    done
    
    echo ""
    print_success "所有配置完成！祝使用愉快 🎉"
    echo ""
}

# 运行主函数
main
