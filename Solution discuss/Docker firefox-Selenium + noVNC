#!/bin/bash

# Docker Selenium + noVNC 完整诊断脚本
# 用途: 快速定位 noVNC 连接问题

set -e

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 容器名称
CONTAINER_NAME="${1:-firefox-selenium}"

echo -e "${BLUE}========================================${NC}"
echo -e "${BLUE}Docker Selenium + noVNC 诊断工具${NC}"
echo -e "${BLUE}容器名称: ${CONTAINER_NAME}${NC}"
echo -e "${BLUE}========================================${NC}\n"

# 辅助函数
check_status() {
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}✓ 通过${NC}"
        return 0
    else
        echo -e "${RED}✗ 失败${NC}"
        return 1
    fi
}

print_step() {
    echo -e "\n${YELLOW}[步骤 $1]${NC} $2"
    echo "----------------------------------------"
}

# 步骤 1: 检查容器是否存在和运行
print_step 1 "检查容器状态"
if docker ps -a --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
    echo -e "容器存在: ${GREEN}是${NC}"
    
    if docker ps --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
        echo -e "运行状态: ${GREEN}运行中${NC}"
        CONTAINER_STATUS=$(docker inspect -f '{{.State.Status}}' ${CONTAINER_NAME})
        echo "详细状态: ${CONTAINER_STATUS}"
        UPTIME=$(docker ps --format '{{.Status}}' --filter "name=${CONTAINER_NAME}")
        echo "运行时间: ${UPTIME}"
    else
        echo -e "运行状态: ${RED}已停止${NC}"
        echo -e "${YELLOW}提示: 运行 'docker start ${CONTAINER_NAME}' 启动容器${NC}"
        exit 1
    fi
else
    echo -e "${RED}✗ 容器不存在${NC}"
    echo -e "${YELLOW}提示: 请先创建容器${NC}"
    exit 1
fi

# 步骤 2: 检查端口映射
print_step 2 "检查端口映射"
echo "容器端口映射:"
docker port ${CONTAINER_NAME} 2>/dev/null || echo "无法获取端口信息"

echo -e "\n检查关键端口:"
for port in 4444 7900 5900; do
    if docker port ${CONTAINER_NAME} | grep -q "${port}"; then
        echo -e "  端口 ${port}: ${GREEN}已映射${NC}"
    else
        if [ "$port" == "5900" ]; then
            echo -e "  端口 ${port}: ${YELLOW}未映射 (内部使用,正常)${NC}"
        else
            echo -e "  端口 ${port}: ${RED}未映射${NC}"
        fi
    fi
done

# 步骤 3: 检查容器内关键进程
print_step 3 "检查容器内进程"

echo "3.1 Xvfb (虚拟显示器):"
if docker exec ${CONTAINER_NAME} ps aux 2>/dev/null | grep -q "[X]vfb"; then
    docker exec ${CONTAINER_NAME} ps aux | grep "[X]vfb"
    check_status
else
    echo -e "${RED}✗ Xvfb 进程未运行${NC}"
fi

echo -e "\n3.2 Firefox 浏览器:"
if docker exec ${CONTAINER_NAME} ps aux 2>/dev/null | grep -q "[f]irefox"; then
    docker exec ${CONTAINER_NAME} ps aux | grep "[f]irefox" | head -3
    check_status
else
    echo -e "${YELLOW}⚠ Firefox 未运行 (正常,等待 Selenium 启动)${NC}"
fi

echo -e "\n3.3 x11vnc (VNC 服务器):"
if docker exec ${CONTAINER_NAME} ps aux 2>/dev/null | grep -q "[x]11vnc"; then
    docker exec ${CONTAINER_NAME} ps aux | grep "[x]11vnc"
    check_status
else
    echo -e "${RED}✗ x11vnc 进程未运行${NC}"
fi

echo -e "\n3.4 noVNC/websockify (WebSocket 代理):"
if docker exec ${CONTAINER_NAME} ps aux 2>/dev/null | grep -q "[n]ovnc"; then
    docker exec ${CONTAINER_NAME} ps aux | grep "[n]ovnc"
    check_status
else
    echo -e "${RED}✗ noVNC 进程未运行${NC}"
fi

echo -e "\n3.5 Selenium Grid:"
if docker exec ${CONTAINER_NAME} ps aux 2>/dev/null | grep -q "[j]ava.*selenium"; then
    echo -e "${GREEN}✓ Selenium 运行中${NC}"
else
    echo -e "${RED}✗ Selenium 未运行${NC}"
fi

# 步骤 4: 检查容器内端口监听
print_step 4 "检查容器内端口监听"

echo "4.1 检查 5900 端口 (x11vnc):"
if docker exec ${CONTAINER_NAME} sh -c "command -v netstat >/dev/null 2>&1" 2>/dev/null; then
    docker exec ${CONTAINER_NAME} netstat -tlnp 2>/dev/null | grep ":5900" || echo "端口 5900 未监听"
elif docker exec ${CONTAINER_NAME} sh -c "command -v ss >/dev/null 2>&1" 2>/dev/null; then
    docker exec ${CONTAINER_NAME} ss -tlnp 2>/dev/null | grep ":5900" || echo "端口 5900 未监听"
else
    echo "无法检查 (缺少 netstat/ss 工具)"
fi

echo -e "\n4.2 检查 7900 端口 (noVNC):"
if docker exec ${CONTAINER_NAME} sh -c "command -v netstat >/dev/null 2>&1" 2>/dev/null; then
    docker exec ${CONTAINER_NAME} netstat -tlnp 2>/dev/null | grep ":7900" || echo "端口 7900 未监听"
elif docker exec ${CONTAINER_NAME} sh -c "command -v ss >/dev/null 2>&1" 2>/dev/null; then
    docker exec ${CONTAINER_NAME} ss -tlnp 2>/dev/null | grep ":7900" || echo "端口 7900 未监听"
else
    echo "无法检查"
fi

echo -e "\n4.3 检查 4444 端口 (Selenium):"
if docker exec ${CONTAINER_NAME} sh -c "command -v netstat >/dev/null 2>&1" 2>/dev/null; then
    docker exec ${CONTAINER_NAME} netstat -tlnp 2>/dev/null | grep ":4444" || echo "端口 4444 未监听"
elif docker exec ${CONTAINER_NAME} sh -c "command -v ss >/dev/null 2>&1" 2>/dev/null; then
    docker exec ${CONTAINER_NAME} ss -tlnp 2>/dev/null | grep ":4444" || echo "端口 4444 未监听"
else
    echo "无法检查"
fi

# 步骤 5: 测试容器内部连接
print_step 5 "测试容器内部连接"

echo "5.1 测试 VNC 端口 (5900):"
if docker exec ${CONTAINER_NAME} curl -s --connect-timeout 3 telnet://localhost:5900 >/dev/null 2>&1; then
    echo -e "${GREEN}✓ 5900 端口可连接${NC}"
else
    echo -e "${RED}✗ 5900 端口无法连接 - 这是关键问题!${NC}"
    echo -e "${YELLOW}原因: x11vnc 可能未正确启动或缺少密码文件${NC}"
fi

echo -e "\n5.2 测试 noVNC HTTP (7900):"
HTTP_CODE=$(docker exec ${CONTAINER_NAME} curl -s -o /dev/null -w "%{http_code}" http://localhost:7900/ 2>/dev/null || echo "000")
if [ "$HTTP_CODE" = "200" ]; then
    echo -e "${GREEN}✓ HTTP 7900 返回 200 OK${NC}"
else
    echo -e "${RED}✗ HTTP 7900 返回 ${HTTP_CODE}${NC}"
fi

echo -e "\n5.3 测试 noVNC WebSocket 升级:"
WS_RESULT=$(docker exec ${CONTAINER_NAME} curl -s --include --no-buffer \
    --header "Connection: Upgrade" \
    --header "Upgrade: websocket" \
    --header "Sec-WebSocket-Key: SGVsbG8sIHdvcmxkIQ==" \
    --header "Sec-WebSocket-Version: 13" \
    http://localhost:7900/ 2>/dev/null | head -5)

if echo "$WS_RESULT" | grep -q "101 Switching Protocols"; then
    echo -e "${GREEN}✓ WebSocket 升级成功${NC}"
    if echo "$WS_RESULT" | grep -q "Failed to connect"; then
        echo -e "${RED}✗ 但连接下游失败 (5900 端口问题)${NC}"
    fi
else
    echo -e "${RED}✗ WebSocket 升级失败${NC}"
fi

# 步骤 6: 检查宿主机端口
print_step 6 "检查宿主机端口访问"

echo "6.1 本地访问 7900 端口:"
if curl -s -o /dev/null -w "%{http_code}" http://localhost:7900/ 2>/dev/null | grep -q "200"; then
    echo -e "${GREEN}✓ 本地可访问${NC}"
else
    echo -e "${RED}✗ 本地无法访问${NC}"
fi

echo -e "\n6.2 检查宿主机防火墙 (iptables):"
if command -v iptables >/dev/null 2>&1; then
    if sudo iptables -L INPUT -n | grep -q "7900"; then
        echo -e "${GREEN}✓ iptables 有 7900 规则${NC}"
        sudo iptables -L INPUT -n -v | grep "7900"
    else
        echo -e "${YELLOW}⚠ iptables 没有明确的 7900 规则${NC}"
    fi
    
    if sudo iptables -L INPUT -n | grep -q "4444"; then
        echo -e "${GREEN}✓ iptables 有 4444 规则${NC}"
    else
        echo -e "${YELLOW}⚠ iptables 没有明确的 4444 规则${NC}"
    fi
else
    echo "iptables 未安装"
fi

# 步骤 7: 检查环境变量
print_step 7 "检查容器环境变量"
echo "VNC 相关配置:"
docker exec ${CONTAINER_NAME} env 2>/dev/null | grep -E "VNC|DISPLAY|SCREEN" | sort

# 步骤 8: 查看最近日志
print_step 8 "查看容器日志 (最近30行)"
docker logs --tail 30 ${CONTAINER_NAME} 2>&1

# 步骤 9: 网络诊断
print_step 9 "外部访问测试"

# 获取公网IP
PUBLIC_IP=$(curl -s ifconfig.me 2>/dev/null || echo "无法获取")
echo "公网 IP: ${PUBLIC_IP}"

if [ "$PUBLIC_IP" != "无法获取" ]; then
    echo -e "\n建议的访问地址:"
    echo -e "  HTTP:  ${GREEN}http://${PUBLIC_IP}:7900/${NC}"
    echo -e "  noVNC: ${GREEN}http://${PUBLIC_IP}:7900/?autoconnect=1${NC}"
    echo -e "  Selenium: ${GREEN}http://${PUBLIC_IP}:4444${NC}"
fi

# 步骤 10: 问题诊断总结
print_step 10 "诊断总结与建议"

ISSUES=0

# 检查关键问题
if ! docker exec ${CONTAINER_NAME} ps aux 2>/dev/null | grep -q "[x]11vnc"; then
    echo -e "${RED}[严重] x11vnc 进程未运行${NC}"
    ISSUES=$((ISSUES + 1))
fi

if ! docker exec ${CONTAINER_NAME} curl -s --connect-timeout 3 telnet://localhost:5900 >/dev/null 2>&1; then
    echo -e "${RED}[严重] VNC 端口 5900 无法连接${NC}"
    echo -e "${YELLOW}解决方案:${NC}"
    echo "  1. 检查是否缺少 VNC 密码文件"
    echo "  2. 重新创建容器并添加: -e SE_VNC_NO_PASSWORD=1"
    echo "  3. 或手动创建密码: docker exec ${CONTAINER_NAME} x11vnc -storepasswd secret /home/seluser/.vnc/passwd"
    ISSUES=$((ISSUES + 1))
fi

if ! docker exec ${CONTAINER_NAME} ps aux 2>/dev/null | grep -q "[n]ovnc"; then
    echo -e "${RED}[严重] noVNC 进程未运行${NC}"
    ISSUES=$((ISSUES + 1))
fi

if [ $ISSUES -eq 0 ]; then
    echo -e "${GREEN}✓ 未发现严重问题,服务应该可以正常访问${NC}"
    echo -e "\n${BLUE}访问方式:${NC}"
    echo "  浏览器访问: http://你的IP或域名:7900/"
    echo "  确保使用 HTTP 而不是 HTTPS"
else
    echo -e "${RED}发现 ${ISSUES} 个严重问题,需要修复${NC}"
fi

echo -e "\n${BLUE}========================================${NC}"
echo -e "${BLUE}诊断完成${NC}"
echo -e "${BLUE}========================================${NC}"
