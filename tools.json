{
  "commands": [
    {
      "id": 1,
      "command": "vmpt=\"2052\" hypt=\"50004\"  uuid=\"57628066-f4a3-47cf-85dc-560d92d4b856\" cdnym=\"chf5762.cloudns.org\" ippz=\"4\" bash <(curl -Ls https://raw.githubusercontent.com/yonggekkk/argosbx/main/argosbx.sh) rep",
      "added_time": "2025-11-16T12:39:47Z"
    },
    {
      "id": 2,
      "command": "docker run -d -p 8181:8181 --name fuclaude-app pengzhile/fuclaude:latest",
      "added_time": "2025-11-16T12:40:52Z"
    },
    {
      "id": 3,
      "command": "systemctl restart caddy",
      "favorite": false,
      "added_time": "2025-12-31T08:10:49Z"
    },
    {
      "id": 4,
      "command": "speaker-test -t wav -c 2 -l 2",
      "favorite": false,
      "added_time": "2025-12-31T08:22:41Z"
    },
    {
      "id": 5,
      "command": "docker run -d --name kkfileview --restart=always -p 8012:8012 yimik/kkfileview:latest",
      "favorite": false,
      "added_time": "2026-01-01T01:40:27Z"
    },
    {
      "id": 6,
      "command": "docker run -d --name=maxkb --restart=always -p 3007:8080 -v C:/maxkb:/opt/maxkb 1panel/maxkb",
      "favorite": false,
      "added_time": "2026-01-01T01:41:50Z"
    },
    {
      "id": 7,
      "command": "docker run -d   --name firefox-selenium   --restart=unless-stopped   -p 4444:4444   -p 7900:7900   -e SE_VNC_NO_PASSWORD=1   -e SE_SCREEN_WIDTH=1920   -e SE_SCREEN_HEIGHT=1080   -v ~/firefox-data:/home/seluser   --shm-size=2g   seleniarm/standalone-firefox",
      "favorite": false,
      "added_time": "2026-01-03T13:22:36Z"
    }
  ],
  "scripts": [
    {
      "id": 1,
      "name": "端口强制杀-彻底释放端口",
      "content": "#!/bin/bash\n\n# Python 虚拟环境进程强杀工具\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nBLUE='\\033[0;34m'\nNC='\\033[0m'\n\necho -e \"${BLUE}╔═══════════════════════════════════╗${NC}\"\necho -e \"${BLUE}║  Python venv 进程强杀工具 v1.0  ║${NC}\"\necho -e \"${BLUE}╚═══════════════════════════════════╝${NC}\\n\"\n\nread -p \"输入端口号: \" PORT\n[ -z \"$PORT\" ] && echo \"端口为空\" && exit 1\n\necho \"\"\necho -e \"${YELLOW}🔍 第一步：查找进程${NC}\"\necho \"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\"\n\nPIDS=$(sudo lsof -ti :$PORT 2>/dev/null)\n\nif [ -z \"$PIDS\" ]; then\n    echo -e \"${GREEN}✓ 端口 $PORT 未被占用${NC}\"\n    exit 0\nfi\n\necho \"找到进程:\"\nfor pid in $PIDS; do\n    CMD=$(ps -o cmd= -p $pid 2>/dev/null)\n    USER=$(ps -o user= -p $pid 2>/dev/null)\n    echo \"  PID: $pid\"\n    echo \"  用户: $USER\"\n    echo \"  命令: $CMD\"\n    echo \"\"\ndone\n\nread -p \"确认强杀? (y/n): \" CONFIRM\n[ \"$CONFIRM\" != \"y\" ] && exit 0\n\n# ============ 关键：先禁用 systemd 自启 ============\necho \"\"\necho -e \"${RED}⚠️  第二步：禁用 systemd 自启（最关键！）${NC}\"\necho \"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\"\n\n# 方案1: 找到所有相关的 systemd 服务\necho \"扫描 systemd 服务...\"\n\nFOUND_SERVICE=0\n\n# 检查标准位置\nfor SERVICE_FILE in /etc/systemd/system/*.service /etc/systemd/user/*.service; do\n    if [ -f \"$SERVICE_FILE\" ]; then\n        # 检查是否包含该端口或 gunicorn/python\n        if grep -q \"Port=$PORT\\|:$PORT\\|gunicorn\\|python.*$PORT\" \"$SERVICE_FILE\" 2>/dev/null; then\n            SERVICE_NAME=$(basename \"$SERVICE_FILE\" .service)\n            echo \"  找到服务: $SERVICE_NAME\"\n            \n            # 三步走：停止 → 禁用 → 屏蔽\n            echo \"    停止服务...\"\n            sudo systemctl stop \"$SERVICE_NAME\" 2>/dev/null\n            \n            echo \"    禁用自启...\"\n            sudo systemctl disable \"$SERVICE_NAME\" 2>/dev/null\n            \n            echo \"    屏蔽服务...\"\n            sudo systemctl mask \"$SERVICE_NAME\" 2>/dev/null\n            \n            echo -e \"    ${GREEN}✓ 已完全禁用${NC}\"\n            FOUND_SERVICE=1\n        fi\n    fi\ndone\n\n# 方案2: 如果没找到，尝试常见名称\nif [ $FOUND_SERVICE -eq 0 ]; then\n    echo \"未在配置文件中找到，尝试常见名称...\"\n    \n    for SERVICE_NAME in gunicorn gunicorn.service app.service django.service; do\n        if systemctl list-unit-files 2>/dev/null | grep -q \"^$SERVICE_NAME\"; then\n            echo \"  找到服务: $SERVICE_NAME\"\n            sudo systemctl stop \"$SERVICE_NAME\" 2>/dev/null\n            sudo systemctl disable \"$SERVICE_NAME\" 2>/dev/null\n            sudo systemctl mask \"$SERVICE_NAME\" 2>/dev/null\n            echo -e \"    ${GREEN}✓ 已禁用${NC}\"\n            FOUND_SERVICE=1\n        fi\n    done\nfi\n\nif [ $FOUND_SERVICE -eq 0 ]; then\n    echo -e \"${YELLOW}⚠️  未找到相关服务（可能使用其他方式启动）${NC}\"\nfi\n\n# 方案3: 重置 systemd\necho \"重置 systemd 状态...\"\nsudo systemctl daemon-reload\nsudo systemctl reset-failed\necho -e \"${GREEN}✓ systemd 已重置${NC}\"\n\n# ============ 杀死所有相关进程 ============\necho \"\"\necho -e \"${RED}⚡ 第三步：强杀进程（20次循环）${NC}\"\necho \"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\"\n\nfor pid in $PIDS; do\n    echo \"  强杀 PID $pid...\"\n    \n    # 杀子进程\n    CHILDREN=$(pgrep -P $pid 2>/dev/null)\n    if [ ! -z \"$CHILDREN\" ]; then\n        for child in $CHILDREN; do\n            sudo kill -9 $child 2>/dev/null\n        done\n    fi\n    \n    # 20次循环强杀\n    for ((i=1; i<=20; i++)); do\n        sudo kill -9 $pid 2>/dev/null 2>&1\n        sleep 0.05\n    done\n    \n    echo -e \"    ${GREEN}✓ 已强杀${NC}\"\ndone\n\n# ============ 杀死所有相关的 Python 进程 ============\necho \"\"\necho -e \"${YELLOW}清理其他 Python 进程...${NC}\"\n\n# 找虚拟环境路径\nVENV_PATHS=$(ps aux | grep -E 'venv|virtualenv' | grep -v grep | awk '{print $12}' | sed 's|/bin/.*||' | sort -u)\n\nif [ ! -z \"$VENV_PATHS\" ]; then\n    for venv_path in $VENV_PATHS; do\n        echo \"  虚拟环境: $venv_path\"\n        VENV_PIDS=$(pgrep -f \"$venv_path\" 2>/dev/null)\n        if [ ! -z \"$VENV_PIDS\" ]; then\n            for venv_pid in $VENV_PIDS; do\n                sudo kill -9 $venv_pid 2>/dev/null\n            done\n            echo \"    ✓ 已清理\"\n        fi\n    done\nfi\n\n# ============ 验证 ============\necho \"\"\necho -e \"${BLUE}📋 第四步：验证结果${NC}\"\necho \"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\"\n\nsleep 2\n\nCHECK=$(sudo lsof -ti :$PORT 2>/dev/null)\n\nif [ -z \"$CHECK\" ]; then\n    echo -e \"${GREEN}✅ 成功！端口 $PORT 已彻底释放${NC}\"\n    echo \"\"\n    echo \"验证命令:\"\n    echo \"  sudo lsof -i :$PORT\"\n    echo \"  sudo netstat -tlnp | grep $PORT\"\n    echo \"\"\n    echo \"后续操作:\"\n    echo \"  1. 修改虚拟环境的 systemd 服务配置\"\n    echo \"  2. 改 Restart=always 为 Restart=no\"\n    echo \"  3. 或完全删除服务配置文件\"\n    exit 0\nelse\n    echo -e \"${RED}⚠️  警告：端口 $CHECK 仍被占用！${NC}\"\n    echo \"\"\n    echo \"可能原因:\"\n    echo \"  1. systemd 在后台重启进程\"\n    echo \"  2. 还有其他监管进程\"\n    echo \"\"\n    echo \"强制方案:\"\n    echo \"  sudo systemctl stop gunicorn\"\n    echo \"  sudo systemctl disable gunicorn\"\n    echo \"  sudo systemctl mask gunicorn\"\n    echo \"  sudo pkill -9 python\"\n    echo \"  sudo pkill -9 gunicorn\"\n    echo \"\"\n    echo \"最后手段:\"\n    echo \"  sudo systemctl daemon-reexec\"\n    echo \"  sudo reboot\"\nfi",
      "lines": 183,
      "added_time": "2025-11-27T13:45:25Z"
    },
    {
      "id": 2,
      "name": "backup VPS 1.0",
      "content": "#!/bin/bash\n# WebDAV VPS 备份与恢复管理器 (v3.2 - ARM 防卡死最终版)\n\n# ==============================================================================\n# 🛠️ 核心配置区 🛠️\n# ==============================================================================\nWEBDAV_URL=\"https://ajiro.infini-cloud.net/dav/\" \nWEBDAV_USER=\"chf5762\"\nWEBDAV_PASS=\"piNdCJ4EPiw5Wtgn\"\n\nREMOTE_FOLDER=\"archives\" \n\nDB_TYPE=\"mysql\"\nDB_USER=\"root\"\nDB_NAME=\"your_api_database\"   # 不需要备份数据库请保持默认或留空\nMAIN_SERVICE_NAME=\"your-api-service\"\n# ==============================================================================\n\nBACKUP_DIRS=(\"/etc\" \"/root\" \"/home\" \"/var/www\" \"/srv\" \"/opt\" \"/var/spool/cron\" \"/etc/letsencrypt\")\n\n# 排除列表 (v3.2: 即使有 --one-file-system，这些显式排除依然保留作为双重保险)\nEXCLUDE_PATTERNS=(\n    \"*.sock\" \n    \"*.log\" \n    \"*.lock\"\n    \"*.iso\"\n    \"*.tar.gz\"\n    \"/var/cache/*\" \n    \"/var/tmp/*\" \n    \"/tmp/*\"\n    \"/var/lib/apt/lists/*\" \n    \"/home/*/.cache\" \n    \"/home/*/Downloads\"\n    \"/etc/unified-monitoring-agenttmp\"\n    \"/proc/*\"\n    \"/sys/*\"\n    \"/run/*\"\n    \"/mnt/*\"\n    \"/media/*\"\n    \"/dev/*\"\n    \"/lost+found\"\n    \"/swapfile\"\n)\n\nREMOTE_NAME=\"mywebdav\"\n\n# --- 0. 环境自检 ---\nprepare_environment() {\n    echo \"--- 🛠️ 正在检查系统环境与依赖 ---\"\n    local PM=\"\"\n    if command -v apt-get >/dev/null; then PM=\"apt\";\n    elif command -v yum >/dev/null; then PM=\"yum\";\n    elif command -v dnf >/dev/null; then PM=\"dnf\";\n    elif command -v apk >/dev/null; then PM=\"apk\";\n    else echo \"❌ 无法识别包管理器，请手动安装 unzip curl tar sudo。\"; exit 1; fi\n\n    local TOOLS=\"curl wget unzip tar sudo\"\n    local MISSING_TOOLS=\"\"\n    for tool in $TOOLS; do\n        if ! command -v $tool >/dev/null; then MISSING_TOOLS=\"$MISSING_TOOLS $tool\"; fi\n    done\n\n    if [ -n \"$MISSING_TOOLS\" ]; then\n        echo \"🔄 正在自动安装依赖: $MISSING_TOOLS\"\n        if [ \"$PM\" == \"apt\" ]; then sudo apt-get update -y -q && sudo apt-get install -y -q $MISSING_TOOLS\n        elif [ \"$PM\" == \"yum\" ] || [ \"$PM\" == \"dnf\" ]; then sudo $PM install -y $MISSING_TOOLS\n        elif [ \"$PM\" == \"apk\" ]; then sudo apk add --no-cache $MISSING_TOOLS\n        fi\n    else\n        echo \"✅ 系统环境依赖正常。\"\n    fi\n}\n\n# --- 1. Rclone 配置 ---\ncheck_and_configure_rclone() {\n    prepare_environment\n    if ! command -v rclone >/dev/null; then\n        echo \"--- ☁️ 正在安装 Rclone ---\"\n        sudo -v ; curl https://rclone.org/install.sh | sudo bash\n    fi\n\n    if rclone listremotes | grep -q \"^${REMOTE_NAME}:\"; then\n        return 0\n    else\n        echo \"--- ⚙️ 正在生成 Rclone 配置文件 ---\"\n        local OB_PASS=$(rclone obscure \"${WEBDAV_PASS}\")\n        mkdir -p ~/.config/rclone\n        rclone config create \"${REMOTE_NAME}\" webdav url=\"${WEBDAV_URL}\" user=\"${WEBDAV_USER}\" pass=\"${OB_PASS}\" vendor=\"other\" --non-interactive >/dev/null 2>&1\n        if [ $? -eq 0 ]; then echo \"✅ Rclone 配置成功！\"; else echo \"❌ Rclone 配置生成失败。\"; exit 1; fi\n    fi\n}\n\n# --- 2. 数据库备份 ---\ndo_db_backup() {\n    local DEST_PATH=$1\n    if [ \"$DB_NAME\" == \"your_api_database\" ] || [ -z \"$DB_NAME\" ]; then\n        echo \"ℹ️ 跳过数据库备份 (未配置 DB_NAME)。\"\n        return 0\n    fi\n\n    local DB_BACKUP_FILE=\"${DEST_PATH}/${DB_NAME}_db_backup.sql\"\n    echo \"--- 📊 正在导出数据库: ${DB_NAME} ---\"\n\n    if [ \"${DB_TYPE}\" == \"mysql\" ]; then\n        mysqldump -u \"${DB_USER}\" \"${DB_NAME}\" > \"${DB_BACKUP_FILE}\" 2>/dev/null\n    elif [ \"${DB_TYPE}\" == \"postgresql\" ]; then\n        pg_dump -U \"${DB_USER}\" \"${DB_NAME}\" > \"${DB_BACKUP_FILE}\" 2>/dev/null\n    fi\n\n    if [ -s \"${DB_BACKUP_FILE}\" ]; then echo \"✅ 数据库导出成功。\"; else rm -f \"${DB_BACKUP_FILE}\"; fi\n}\n\n# --- 3. 系统状态备份 ---\ndo_system_check_backup() {\n    local DEST_PATH=$1\n    if [ -z \"$MAIN_SERVICE_NAME\" ] || [ \"$MAIN_SERVICE_NAME\" == \"your-api-service\" ]; then return 0; fi\n    local STATE_FILE=\"${DEST_PATH}/system_state.txt\"\n    if systemctl is-enabled \"${MAIN_SERVICE_NAME}\" >/dev/null 2>&1; then echo \"SERVICE_ENABLED=true\" > \"${STATE_FILE}\"; else echo \"SERVICE_ENABLED=false\" > \"${STATE_FILE}\"; fi\n    if [ -f \"/etc/ssh/sshd_config\" ]; then stat -c \"SSHD_CONFIG_PERMS=%a\" /etc/ssh/sshd_config >> \"${STATE_FILE}\"; fi\n}\n\n# --- 4. 恢复逻辑 ---\ndo_system_restore() {\n    local RESTORE_PATH=$1\n    if [ -z \"$MAIN_SERVICE_NAME\" ] || [ \"$MAIN_SERVICE_NAME\" == \"your-api-service\" ]; then return 0; fi\n    local STATE_FILE=\"${RESTORE_PATH}/system_state.txt\"\n    echo \"--- 🔄 恢复服务状态 ---\"\n    sudo systemctl daemon-reload\n    if [ -f \"${STATE_FILE}\" ]; then\n        source \"${STATE_FILE}\"\n        if [ \"${SERVICE_ENABLED}\" == \"true\" ]; then sudo systemctl enable \"${MAIN_SERVICE_NAME}\" 2>/dev/null; sudo systemctl start \"${MAIN_SERVICE_NAME}\" 2>/dev/null; else sudo systemctl disable \"${MAIN_SERVICE_NAME}\" 2>/dev/null; fi\n        [ -n \"${SSHD_CONFIG_PERMS}\" ] && chmod \"${SSHD_CONFIG_PERMS}\" /etc/ssh/sshd_config 2>/dev/null\n    fi\n}\n\n# --- 功能: 备份 (防卡死版) ---\nbackup_to_webdav() {\n    check_and_configure_rclone\n\n    local TEMP_DIR=\"/tmp/vps_backup_temp_$(date +%s)\"\n    local TIMESTAMP=$(date +%Y%m%d_%H%M%S)\n    local HOSTNAME=$(hostname)\n    local ARCHIVE_NAME=\"full_backup_${HOSTNAME}_${TIMESTAMP}.tar.gz\"\n    local LOCAL_BACKUP_FOLDER=\"${TEMP_DIR}/payload\"\n    \n    echo \"--- 🚀 开始备份 (ARM 优化模式) ---\"\n    \n    mkdir -p \"${LOCAL_BACKUP_FOLDER}\"\n    do_db_backup \"${LOCAL_BACKUP_FOLDER}\"\n    do_system_check_backup \"${LOCAL_BACKUP_FOLDER}\"\n\n    local TEMP_FILE=\"/tmp/backup_list.txt\"\n    rm -f \"${TEMP_FILE}\"\n    for dir in \"${BACKUP_DIRS[@]}\"; do [ -d \"$dir\" ] && echo \"$dir\" >> \"${TEMP_FILE}\"; done\n\n    echo \"--- 📦 正在打包 (已启用 '防跨文件系统' 保护) ---\"\n    echo \"ℹ️  正在生成压缩包，您将看到文件列表滚动，证明没有卡死...\"\n    \n    # 核心修改：\n    # 1. nice -n 10: 降低 CPU 优先级，防止 ARM 机器 SSH 卡死\n    # 2. --one-file-system: 关键参数！防止读取 /proc 虚拟文件导致无限等待\n    # 3. -v: 显示文件列表，让用户知道进度\n    # 4. 这里的 stderr 重定向被移除，以便看到任何错误\n    \n    sudo nice -n 10 tar -zcvf \"${TEMP_DIR}/${ARCHIVE_NAME}\" \\\n        --one-file-system \\\n        -C / -T \"${TEMP_FILE}\" \\\n        $(for pattern in \"${EXCLUDE_PATTERNS[@]}\"; do echo \"--exclude='${pattern}'\"; done) \\\n        --directory=\"${TEMP_DIR}\" \"payload\" \\\n        | awk 'NR%100==0 {printf \"\\r已处理 %d 个文件...\", NR} END {print \"\\r打包完成！\"}'\n\n    TAR_EXIT_CODE=${PIPESTATUS[0]} # 获取管道前 tar 的退出码\n\n    # 0 = 成功, 1 = 有警告 (正常)\n    if [ $TAR_EXIT_CODE -eq 0 ] || [ $TAR_EXIT_CODE -eq 1 ]; then\n        echo -e \"\\n✅ 打包成功。\"\n    else\n        echo -e \"\\n❌ 打包失败 (错误码: $TAR_EXIT_CODE)。\"\n        rm -rf \"${TEMP_DIR}\"\n        return 1\n    fi\n\n    echo \"--- 📤 正在上传到 WebDAV ---\"\n    rclone copy \"${TEMP_DIR}/${ARCHIVE_NAME}\" \"${REMOTE_NAME}:${REMOTE_FOLDER}/\" --progress\n\n    if [ $? -eq 0 ]; then echo \"✅ 备份上传成功！\"; else echo \"❌ 上传失败，请检查网络。\"; fi\n\n    rm -f \"${TEMP_FILE}\"\n    sudo rm -rf \"${TEMP_DIR}\"\n}\n\n# --- 功能: 恢复 ---\nrestore_from_webdav() {\n    check_and_configure_rclone\n    echo \"--- 📥 获取远程备份列表 ---\"\n    mapfile -t BACKUP_FILES < <(rclone lsf \"${REMOTE_NAME}:${REMOTE_FOLDER}/\" --files-only --include \"*.tar.gz\" | sort -r)\n\n    if [ ${#BACKUP_FILES[@]} -eq 0 ]; then echo \"❌ 未找到备份文件。\"; return 1; fi\n\n    local i=1\n    for file in \"${BACKUP_FILES[@]}\"; do echo \"$i) $file\"; i=$((i + 1)); done\n\n    read -p \"请输入序号: \" CHOICE\n    if ! [[ \"$CHOICE\" =~ ^[0-9]+$ ]] || [ \"$CHOICE\" -lt 1 ] || [ \"$CHOICE\" -gt ${#BACKUP_FILES[@]} ]; then echo \"无效输入\"; return 1; fi\n    \n    local SELECTED_FILE=\"${BACKUP_FILES[$((CHOICE - 1))]}\"\n    \n    echo \"⚠️  注意：即将覆盖系统文件！\"\n    read -r -p \"确认请输入 YES : \" response\n    if [ \"$response\" != \"YES\" ]; then echo \"已取消。\"; return 0; fi\n\n    local TEMP_DIR=\"/tmp/restore_temp_$(date +%s)\"\n    mkdir -p \"${TEMP_DIR}\"\n    echo \"--- ⬇️ 下载备份... ---\"\n    rclone copy \"${REMOTE_NAME}:${REMOTE_FOLDER}/${SELECTED_FILE}\" \"${TEMP_DIR}/\" --progress\n\n    echo \"--- 🔄 解压覆盖... ---\"\n    # 解压也加上 --overwrite 确保覆盖\n    sudo tar -xzpf \"${TEMP_DIR}/${SELECTED_FILE}\" -C /\n    \n    local RESTORE_PATH=\"/payload\"\n    if [ -d \"${RESTORE_PATH}\" ]; then\n        do_system_restore \"${RESTORE_PATH}\"\n        sudo rm -rf \"${RESTORE_PATH}\"\n    fi\n\n    sudo rm -rf \"${TEMP_DIR}\"\n    echo \"--- ✅ 恢复完成！ ---\"\n}\n\n# --- Cron ---\nsetup_cron() {\n    read -p \"频率 (1=每日 2=每周 3=每月): \" FREQUENCY\n    case \"$FREQUENCY\" in\n        1) SCHEDULE=\"0 3 * * *\" ;;\n        2) SCHEDULE=\"0 3 * * 0\" ;;\n        3) SCHEDULE=\"0 3 1 * *\" ;;\n        *) echo \"无效\"; return 1;;\n    esac\n    local SCRIPT_PATH=$(realpath \"$0\")\n    local CRON_JOB=\"${SCHEDULE} root bash ${SCRIPT_PATH} execute_backup >> /var/log/vps_backup.log 2>&1\"\n    (sudo crontab -l 2>/dev/null | grep -v \"execute_backup\") | sudo crontab -\n    (sudo crontab -l 2>/dev/null; echo \"${CRON_JOB}\") | sudo crontab -\n    echo \"✅ 定时任务已设置。\"\n}\n\n# --- Main ---\nif [ \"$1\" == \"execute_backup\" ]; then backup_to_webdav; exit $?; fi\nif [ \"$(id -u)\" != \"0\" ]; then echo \"请使用 sudo\"; exit 1; fi\n\nwhile true; do\n    echo \"WebDAV 备份管理器 (v3.2 ARM 防卡死版)\"\n    echo \"1) 初始化\"\n    echo \"2) 备份\"\n    echo \"3) 恢复\"\n    echo \"4) 定时任务\"\n    echo \"5) 退出\"\n    read -p \"选择: \" CHOICE\n    case \"$CHOICE\" in\n        1) check_and_configure_rclone;;\n        2) backup_to_webdav;;\n        3) restore_from_webdav;;\n        4) setup_cron;;\n        5) exit 0;;\n    esac\ndone",
      "lines": 265,
      "added_time": "2025-12-09T07:45:01Z"
    },
    {
      "id": 3,
      "name": "docker manager",
      "content": "#!/bin/bash\n\n# Docker 全方位管理脚本\n# 功能：容器和镜像的全方位管理，支持批量操作\n\n# 颜色定义\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nBLUE='\\033[0;34m'\nCYAN='\\033[0;36m'\nNC='\\033[0m' # 无颜色\n\n# 检查 Docker 是否安装和运行\ncheck_docker() {\n    if ! command -v docker &> /dev/null; then\n        echo -e \"${RED}错误：Docker 未安装${NC}\"\n        exit 1\n    fi\n    \n    if ! docker ps &> /dev/null; then\n        echo -e \"${RED}错误：无法连接到 Docker，请检查 Docker 服务是否运行或权限是否足够${NC}\"\n        exit 1\n    fi\n}\n\n# 打印分隔线\nprint_line() {\n    echo -e \"${CYAN}========================================${NC}\"\n}\n\n# 显示主菜单\nshow_main_menu() {\n    clear\n    print_line\n    echo -e \"${CYAN}          Docker 管理工具${NC}\"\n    print_line\n    echo -e \"${YELLOW}1.${NC} 容器管理\"\n    echo -e \"${YELLOW}2.${NC} 镜像管理\"\n    echo -e \"${YELLOW}3.${NC} 退出\"\n    print_line\n}\n\n# 显示容器管理菜单\nshow_container_menu() {\n    clear\n    print_line\n    echo -e \"${CYAN}          容器管理${NC}\"\n    print_line\n    echo -e \"${YELLOW}1.${NC} 列出所有容器\"\n    echo -e \"${YELLOW}2.${NC} 启动容器\"\n    echo -e \"${YELLOW}3.${NC} 停止容器\"\n    echo -e \"${YELLOW}4.${NC} 重启容器\"\n    echo -e \"${YELLOW}5.${NC} 删除容器（强制）\"\n    echo -e \"${YELLOW}6.${NC} 查看容器日志\"\n    echo -e \"${YELLOW}7.${NC} 返回主菜单\"\n    print_line\n}\n\n# 显示镜像管理菜单\nshow_image_menu() {\n    clear\n    print_line\n    echo -e \"${CYAN}          镜像管理${NC}\"\n    print_line\n    echo -e \"${YELLOW}1.${NC} 列出所有镜像\"\n    echo -e \"${YELLOW}2.${NC} 删除镜像（强制）\"\n    echo -e \"${YELLOW}3.${NC} 清理未使用的镜像\"\n    echo -e \"${YELLOW}4.${NC} 返回主菜单\"\n    print_line\n}\n\n# 列出所有容器\nlist_containers() {\n    clear\n    print_line\n    echo -e \"${CYAN}          容器列表${NC}\"\n    print_line\n    \n    # 运行中的容器\n    echo -e \"\\n${GREEN}运行中的容器：${NC}\"\n    running_containers=($(docker ps --format \"{{.ID}}\"))\n    \n    if [ ${#running_containers[@]} -eq 0 ]; then\n        echo \"  无运行中的容器\"\n    else\n        printf \"%-6s %-15s %-25s %-15s %-30s\\n\" \"编号\" \"容器ID\" \"名称\" \"状态\" \"端口\"\n        echo \"---------------------------------------------------------------------------------------------------\"\n        for i in \"${!running_containers[@]}\"; do\n            id=\"${running_containers[$i]}\"\n            name=$(docker ps --filter \"id=$id\" --format \"{{.Names}}\")\n            status=$(docker ps --filter \"id=$id\" --format \"{{.Status}}\")\n            ports=$(docker ps --filter \"id=$id\" --format \"{{.Ports}}\")\n            printf \"${GREEN}%-6s %-15s %-25s %-15s %-30s${NC}\\n\" \"$((i+1))\" \"${id:0:12}\" \"$name\" \"运行中\" \"$ports\"\n        done\n    fi\n    \n    # 已停止的容器\n    echo -e \"\\n${RED}已停止的容器：${NC}\"\n    stopped_containers=($(docker ps -a --filter \"status=exited\" --filter \"status=created\" --format \"{{.ID}}\"))\n    \n    if [ ${#stopped_containers[@]} -eq 0 ]; then\n        echo \"  无已停止的容器\"\n    else\n        printf \"%-6s %-15s %-25s %-15s %-30s\\n\" \"编号\" \"容器ID\" \"名称\" \"状态\" \"端口\"\n        echo \"---------------------------------------------------------------------------------------------------\"\n        offset=${#running_containers[@]}\n        for i in \"${!stopped_containers[@]}\"; do\n            id=\"${stopped_containers[$i]}\"\n            name=$(docker ps -a --filter \"id=$id\" --format \"{{.Names}}\")\n            status=$(docker ps -a --filter \"id=$id\" --format \"{{.Status}}\")\n            ports=$(docker ps -a --filter \"id=$id\" --format \"{{.Ports}}\")\n            printf \"${RED}%-6s %-15s %-25s %-15s %-30s${NC}\\n\" \"$((offset+i+1))\" \"${id:0:12}\" \"$name\" \"已停止\" \"$ports\"\n        done\n    fi\n    \n    print_line\n}\n\n# 获取所有容器（运行中+已停止）\nget_all_containers() {\n    running=($(docker ps --format \"{{.ID}}\"))\n    stopped=($(docker ps -a --filter \"status=exited\" --filter \"status=created\" --format \"{{.ID}}\"))\n    all_containers=(\"${running[@]}\" \"${stopped[@]}\")\n}\n\n# 启动容器\nstart_containers() {\n    list_containers\n    get_all_containers\n    \n    if [ ${#all_containers[@]} -eq 0 ]; then\n        echo -e \"${YELLOW}没有可用的容器${NC}\"\n        read -p \"按回车键继续...\"\n        return\n    fi\n    \n    echo -e \"\\n${CYAN}请输入要启动的容器编号（空格分隔，如：1 2 3）：${NC}\"\n    read -r input\n    \n    if [ -z \"$input\" ]; then\n        return\n    fi\n    \n    for num in $input; do\n        if [[ \"$num\" =~ ^[0-9]+$ ]] && [ \"$num\" -ge 1 ] && [ \"$num\" -le ${#all_containers[@]} ]; then\n            container_id=\"${all_containers[$((num-1))]}\"\n            echo -e \"${GREEN}正在启动容器 $num: $container_id${NC}\"\n            docker start \"$container_id\"\n        else\n            echo -e \"${RED}无效的编号: $num${NC}\"\n        fi\n    done\n    \n    echo -e \"${GREEN}操作完成${NC}\"\n    read -p \"按回车键继续...\"\n}\n\n# 停止容器\nstop_containers() {\n    list_containers\n    get_all_containers\n    \n    if [ ${#all_containers[@]} -eq 0 ]; then\n        echo -e \"${YELLOW}没有可用的容器${NC}\"\n        read -p \"按回车键继续...\"\n        return\n    fi\n    \n    echo -e \"\\n${CYAN}请输入要停止的容器编号（空格分隔，如：1 2 3）：${NC}\"\n    read -r input\n    \n    if [ -z \"$input\" ]; then\n        return\n    fi\n    \n    for num in $input; do\n        if [[ \"$num\" =~ ^[0-9]+$ ]] && [ \"$num\" -ge 1 ] && [ \"$num\" -le ${#all_containers[@]} ]; then\n            container_id=\"${all_containers[$((num-1))]}\"\n            echo -e \"${YELLOW}正在停止容器 $num: $container_id${NC}\"\n            docker stop \"$container_id\"\n        else\n            echo -e \"${RED}无效的编号: $num${NC}\"\n        fi\n    done\n    \n    echo -e \"${GREEN}操作完成${NC}\"\n    read -p \"按回车键继续...\"\n}\n\n# 重启容器\nrestart_containers() {\n    list_containers\n    get_all_containers\n    \n    if [ ${#all_containers[@]} -eq 0 ]; then\n        echo -e \"${YELLOW}没有可用的容器${NC}\"\n        read -p \"按回车键继续...\"\n        return\n    fi\n    \n    echo -e \"\\n${CYAN}请输入要重启的容器编号（空格分隔，如：1 2 3）：${NC}\"\n    read -r input\n    \n    if [ -z \"$input\" ]; then\n        return\n    fi\n    \n    for num in $input; do\n        if [[ \"$num\" =~ ^[0-9]+$ ]] && [ \"$num\" -ge 1 ] && [ \"$num\" -le ${#all_containers[@]} ]; then\n            container_id=\"${all_containers[$((num-1))]}\"\n            echo -e \"${BLUE}正在重启容器 $num: $container_id${NC}\"\n            docker restart \"$container_id\"\n        else\n            echo -e \"${RED}无效的编号: $num${NC}\"\n        fi\n    done\n    \n    echo -e \"${GREEN}操作完成${NC}\"\n    read -p \"按回车键继续...\"\n}\n\n# 删除容器（强制）\nremove_containers() {\n    list_containers\n    get_all_containers\n    \n    if [ ${#all_containers[@]} -eq 0 ]; then\n        echo -e \"${YELLOW}没有可用的容器${NC}\"\n        read -p \"按回车键继续...\"\n        return\n    fi\n    \n    echo -e \"\\n${RED}请输入要删除的容器编号（空格分隔，如：1 2 3）：${NC}\"\n    read -r input\n    \n    if [ -z \"$input\" ]; then\n        return\n    fi\n    \n    for num in $input; do\n        if [[ \"$num\" =~ ^[0-9]+$ ]] && [ \"$num\" -ge 1 ] && [ \"$num\" -le ${#all_containers[@]} ]; then\n            container_id=\"${all_containers[$((num-1))]}\"\n            echo -e \"${RED}正在强制删除容器 $num: $container_id${NC}\"\n            docker rm -f \"$container_id\"\n        else\n            echo -e \"${RED}无效的编                          : $num${NC}\"\n        fi\n    done\n    \n    echo -e \"${GREEN}操作完成${NC}\"\n    read -p \"按回车键继续...\"\n}\n\n# 查看容器日志\nview_container_logs() {\n    list_containers\n    get_all_containers\n    \n    if [ ${#all_containers[@]} -eq 0 ]; then\n        echo -e \"${YELLOW}没有可用的容器${NC}\"\n        read -p \"按回车键继续...\"\n        return\n    fi\n    \n    echo -e \"\\n${CYAN}请输入要查看日志的容器编号：${NC}\"\n    read -r num\n    \n    if [[ \"$num\" =~ ^[0-9]+$ ]] && [ \"$num\" -ge 1 ] && [ \"$num\" -le ${#all_containers[@]} ]; then\n        container_id=\"${all_containers[$((num-1))]}\"\n        echo -e \"${BLUE}显示容器日志（最后100行）: $container_id${NC}\"\n        print_line\n        docker logs --tail 100 \"$container_id\"\n        print_line\n    else\n        echo -e \"${RED}无效的编号${NC}\"\n    fi\n    \n    read -p \"按回车键继续...\"\n}\n\n# 列出所有镜像\nlist_images() {\n    clear\n    print_line\n    echo -e \"${CYAN}          镜像列表${NC}\"\n    print_line\n    \n    images=($(docker images --format \"{{.ID}}\"))\n    \n    if [ ${#images[@]} -eq 0 ]; then\n        echo -e \"${YELLOW}没有可用的镜像${NC}\"\n    else\n        printf \"\\n%-6s %-20s %-30s %-15s %-20s\\n\" \"编号\" \"镜像ID\" \"仓库\" \"标签\" \"大小\"\n        echo \"---------------------------------------------------------------------------------------------------\"\n        for i in \"${!images[@]}\"; do\n            id=\"${images[$i]}\"\n            repo=$(docker images --filter \"id=$id\" --format \"{{.Repository}}\")\n            tag=$(docker images --filter \"id=$id\" --format \"{{.Tag}}\")\n            size=$(docker images --filter \"id=$id\" --format \"{{.Size}}\")\n            printf \"${BLUE}%-6s %-20s %-30s %-15s %-20s${NC}\\n\" \"$((i+1))\" \"${id:0:12}\" \"$repo\" \"$tag\" \"$size\"\n        done\n    fi\n    \n    print_line\n}\n\n# 删除镜像（强制）\nremove_images() {\n    list_images\n    images=($(docker images --format \"{{.ID}}\"))\n    \n    if [ ${#images[@]} -eq 0 ]; then\n        echo -e \"${YELLOW}没有可用的镜像${NC}\"\n        read -p \"按回车键继续...\"\n        return\n    fi\n    \n    echo -e \"\\n${RED}请输入要删除的镜像编号（空格分隔，如：1 2 3）：${NC}\"\n    read -r input\n    \n    if [ -z \"$input\" ]; then\n        return\n    fi\n    \n    for num in $input; do\n        if [[ \"$num\" =~ ^[0-9]+$ ]] && [ \"$num\" -ge 1 ] && [ \"$num\" -le ${#images[@]} ]; then\n            image_id=\"${images[$((num-1))]}\"\n            echo -e \"${RED}正在强制删除镜像 $num: $image_id${NC}\"\n            docker rmi -f \"$image_id\"\n        else\n            echo -e \"${RED}无效的编号: $num${NC}\"\n        fi\n    done\n    \n    echo -e \"${GREEN}操作完成${NC}\"\n    read -p \"按回车键继续...\"\n}\n\n# 清理未使用的镜像\nprune_images() {\n    clear\n    print_line\n    echo -e \"${CYAN}          清理未使用的镜像${NC}\"\n    print_line\n    echo -e \"${YELLOW}正在清理未使用的镜像...${NC}\\n\"\n    docker image prune -a -f\n    echo -e \"\\n${GREEN}清理完成${NC}\"\n    read -p \"按回车键继续...\"\n}\n\n# 容器管理主循环\ncontainer_management() {\n    while true; do\n        show_container_menu\n        read -p \"请选择操作: \" choice\n        \n        case $choice in\n            1) list_containers; read -p \"按回车键继续...\" ;;\n            2) start_containers ;;\n            3) stop_containers ;;\n            4) restart_containers ;;\n            5) remove_containers ;;\n            6) view_container_logs ;;\n            7) break ;;\n            *) echo -e \"${RED}无效选择${NC}\"; sleep 1 ;;\n        esac\n    done\n}\n\n# 镜像管理主循环\nimage_management() {\n    while true; do\n        show_image_menu\n        read -p \"请选择操作: \" choice\n        \n        case $choice in\n            1) list_images; read -p \"按回车键继续...\" ;;\n            2) remove_images ;;\n            3) prune_images ;;\n            4) break ;;\n            *) echo -e \"${RED}无效选择${NC}\"; sleep 1 ;;\n        esac\n    done\n}\n\n# 主程序\nmain() {\n    check_docker\n    \n    while true; do\n        show_main_menu\n        read -p \"请选择操作: \" choice\n        \n        case $choice in\n            1) container_management ;;\n            2) image_management ;;\n            3) echo -e \"${GREEN}感谢使用，再见！${NC}\"; exit 0 ;;\n            *) echo -e \"${RED}无效选择${NC}\"; sleep 1 ;;\n        esac\n    done\n}\n\n# 运行主程序\nmain",
      "lines": 404,
      "added_time": "2025-12-09T11:10:10Z"
    },
    {
      "id": 4,
      "name": "UFW iptable 设置",
      "content": "sudo bash -c 'cat > /usr/local/bin/u.sh << \"EOF\"\n#!/bin/bash\n################################################################################\n# UFW 防火墙一键管理脚本 v1.1\n# 功能: 安装、开关、TCP/UDP全开、自定义端口、查看底层 Iptables\n################################################################################\n\n# 颜色定义\nRED=\"\\033[31m\"\nGREEN=\"\\033[32m\"\nYELLOW=\"\\033[33m\"\nPLAIN=\"\\033[0m\"\n\n# 检查 Root 权限\ncheck_root() {\n    if [[ $EUID -ne 0 ]]; then\n        echo -e \"${RED}错误: 请使用 root 权限运行此脚本！${PLAIN}\"\n        echo -e \"请运行: sudo bash $0\"\n        exit 1\n    fi\n}\n\n# 检查并安装 UFW\ncheck_install() {\n    if ! command -v ufw &> /dev/null; then\n        echo -e \"${YELLOW}正在安装 UFW...${PLAIN}\"\n        if command -v apt-get &> /dev/null; then\n            apt-get update -y && apt-get install ufw -y\n        elif command -v yum &> /dev/null; then\n            yum install ufw -y\n        fi\n        echo -e \"${GREEN}UFW 安装完成！${PLAIN}\"\n    fi\n}\n\n# 获取防火墙状态\nget_status() {\n    if ufw status | grep -q \"Status: active\"; then\n        echo -e \"${GREEN}运行中 (Active)${PLAIN}\"\n    else\n        echo -e \"${RED}已关闭 (Inactive)${PLAIN}\"\n    fi\n}\n\n# 开启防火墙 (带 SSH 安全检测)\nenable_ufw() {\n    echo -e \"${YELLOW}正在开启防火墙...${PLAIN}\"\n    \n    ufw default deny incoming\n    ufw default allow outgoing\n    \n    local ssh_port=$(grep \"^Port\" /etc/ssh/sshd_config | head -1 | awk \"{print \\$2}\")\n    if [[ -z \"$ssh_port\" ]]; then\n        ssh_port=22\n    fi\n    \n    echo -e \"${YELLOW}检测到 SSH 端口为: $ssh_port${PLAIN}\"\n    read -p \"确认放行 SSH 端口 $ssh_port? [Y/n]: \" confirm\n    confirm=${confirm:-Y}\n    \n    if [[ $confirm =~ ^[Yy]$ ]]; then\n        ufw allow \"$ssh_port/tcp\"\n        echo -e \"${GREEN}已放行端口 $ssh_port (TCP)${PLAIN}\"\n    else\n        read -p \"请输入你要放行的 SSH 端口: \" custom_ssh\n        ufw allow \"$custom_ssh/tcp\"\n    fi\n\n    echo \"y\" | ufw enable\n    echo -e \"${GREEN}防火墙已开启！${PLAIN}\"\n}\n\n# 关闭防火墙\ndisable_ufw() {\n    ufw disable\n    echo -e \"${RED}防火墙已关闭！${PLAIN}\"\n}\n\n# 开放指定端口\nallow_port() {\n    echo \"\"\n    read -p \"请输入端口号 (例如 80 或 8080:9090): \" port\n    echo \"选择协议:\"\n    echo \"1. TCP\"\n    echo \"2. UDP\"\n    echo \"3. TCP + UDP (Both)\"\n    read -p \"请选择 [1-3]: \" proto_choice\n    \n    case $proto_choice in\n        1) ufw allow \"$port/tcp\";;\n        2) ufw allow \"$port/udp\";;\n        3) ufw allow \"$port\";;\n        *) echo -e \"${RED}无效选择${PLAIN}\"; return;;\n    esac\n    \n    echo -e \"${GREEN}规则已添加！${PLAIN}\"\n    ufw reload\n}\n\n# 删除规则\ndelete_rule() {\n    echo \"\"\n    echo -e \"${YELLOW}当前规则列表 (带编号):${PLAIN}\"\n    ufw status numbered\n    echo \"\"\n    read -p \"请输入要删除的规则【编号】 (输入 0 返回): \" num\n    \n    if [[ \"$num\" == \"0\" ]]; then\n        return\n    fi\n    \n    echo \"y\" | ufw delete \"$num\"\n    echo -e \"${GREEN}规则已删除！${PLAIN}\"\n}\n\n# 开放所有 TCP\nallow_all_tcp() {\n    read -p \"⚠️  警告：允许所有 TCP 连接？[y/N]: \" confirm\n    if [[ $confirm =~ ^[Yy]$ ]]; then\n        ufw allow 1:65535/tcp\n        echo -e \"${GREEN}已开放所有 TCP 端口${PLAIN}\"\n    fi\n}\n\n# 开放所有 UDP\nallow_all_udp() {\n    read -p \"⚠️  警告：允许所有 UDP 连接？[y/N]: \" confirm\n    if [[ $confirm =~ ^[Yy]$ ]]; then\n        ufw allow 1:65535/udp\n        echo -e \"${GREEN}已开放所有 UDP 端口${PLAIN}\"\n    fi\n}\n\n# 重置防火墙\nreset_ufw() {\n    read -p \"⚠️  危险：清除所有规则并重置？[y/N]: \" confirm\n    if [[ $confirm =~ ^[Yy]$ ]]; then\n        echo \"y\" | ufw reset\n        echo -e \"${GREEN}已重置。${PLAIN}\"\n    fi\n}\n\n# 查看 Iptables INPUT 链 (新增功能)\nview_iptables() {\n    echo \"\"\n    echo -e \"${YELLOW}正在查看 Iptables INPUT 链规则...${PLAIN}\"\n    echo \"--------------------------------------------------------\"\n    # 直接执行用户请求的命令\n    iptables -L INPUT -n --line-numbers\n    echo \"--------------------------------------------------------\"\n    echo -e \"${YELLOW}说明: 如果 UFW 开启，此处通常显示跳转到 ufw-xxx 的链。${PLAIN}\"\n    read -p \"按回车继续...\"\n}\n\n# 主菜单\nshow_menu() {\n    clear\n    echo \"################################################\"\n    echo \"#           UFW 防火墙管理脚本 v1.1            #\"\n    echo \"################################################\"\n    echo -e \"当前状态: $(get_status)\"\n    echo \"\"\n    echo \" 1. ✅ 开启防火墙 (自动放行SSH)\"\n    echo \" 2. ⛔ 关闭防火墙\"\n    echo \" 3. 🔍 查看 UFW 规则 (简易)\"\n    echo \"--------------------------------\"\n    echo \" 4. ➕ 开放 指定端口 (TCP/UDP)\"\n    echo \" 5. ➖ 删除 指定规则 (按编号)\"\n    echo \"--------------------------------\"\n    echo \" 6. 🔓 开放 所有 TCP (1-65535)\"\n    echo \" 7. 🔓 开放 所有 UDP (1-65535)\"\n    echo \"--------------------------------\"\n    echo \" 8. ♻️  重置 所有规则\"\n    echo \" 9. 🕵️  查看 Iptables INPUT 规则 (底层)\"\n    echo \" 0. 退出\"\n    echo \"\"\n    read -p \"请选择 [0-9]: \" choice\n    \n    case $choice in\n        1) enable_ufw ;;\n        2) disable_ufw ;;\n        3) ufw status verbose; read -p \"按回车继续...\" ;;\n        4) allow_port ;;\n        5) delete_rule ;;\n        6) allow_all_tcp ;;\n        7) allow_all_udp ;;\n        8) reset_ufw ;;\n        9) view_iptables ;;\n        0) exit 0 ;;\n        *) echo -e \"${RED}无效选项${PLAIN}\" ;;\n    esac\n}\n\n# 主程序\ncheck_root\ncheck_install\n\nwhile true; do\n    show_menu\n    echo \"\"\n    read -p \"按回车返回主菜单...\"\ndone\nEOF\nchmod +x /usr/local/bin/u.sh\n/usr/local/bin/u.sh'",
      "lines": 204,
      "added_time": "2025-12-12T09:07:09Z"
    },
    {
      "id": 5,
      "name": "Tailscale 管理",
      "content": "#!/bin/bash\n\n# Tailscale 一键工具箱\n# 功能：安装、配置 exit node、卸载等\n\n# 颜色定义\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nBLUE='\\033[0;34m'\nNC='\\033[0m'\n\n# 检查 root 权限\ncheck_root() {\n  if [ \"$EUID\" -ne 0 ]; then\n    echo -e \"${RED}❌ 需要 root 权限运行此脚本${NC}\"\n    exit 1\n  fi\n}\n\n# 菜单显示\nshow_menu() {\n  clear\n  echo -e \"${BLUE}==========================================\"\n  echo \"      Tailscale 一键工具箱\"\n  echo \"==========================================${NC}\"\n  echo \"\"\n  echo -e \"${YELLOW}[1]${NC} 安装 Tailscale 并启动\"\n  echo -e \"${YELLOW}[2]${NC} 查看 Exit Nodes 并连接\"\n  echo -e \"${YELLOW}[3]${NC} 把本机设置为 Exit Node\"\n  echo -e \"${YELLOW}[4]${NC} 查看 Tailscale 状态\"\n  echo -e \"${YELLOW}[5]${NC} 断开 Exit Node\"\n  echo -e \"${YELLOW}[6]${NC} 卸载 Tailscale\"\n  echo -e \"${YELLOW}[7]${NC} 退出\"\n  echo \"\"\n  echo -e \"${BLUE}=========================================${NC}\"\n}\n\n# 1. 安装 Tailscale\ninstall_tailscale() {\n  echo -e \"${GREEN}📦 安装 Tailscale...${NC}\"\n  echo \"\"\n  \n  # 检查是否已安装\n  if command -v tailscale &> /dev/null; then\n    echo -e \"${YELLOW}⚠️ Tailscale 已安装${NC}\"\n    echo \"\"\n    echo -e \"${BLUE}启动 Tailscale 服务...${NC}\"\n  else\n    echo -e \"${BLUE}下载并安装 Tailscale...${NC}\"\n    curl -fsSL https://tailscale.com/install.sh | sh\n    \n    if [ $? -ne 0 ]; then\n      echo -e \"${RED}❌ 安装失败${NC}\"\n      read -p \"按 Enter 继续...\"\n      return\n    fi\n    echo -e \"${GREEN}✓ Tailscale 安装完成${NC}\"\n  fi\n  \n  echo \"\"\n  echo -e \"${BLUE}🔄 启动 Tailscale 服务...${NC}\"\n  systemctl start tailscaled\n  systemctl enable tailscaled\n  sleep 2\n  \n  if systemctl is-active --quiet tailscaled; then\n    echo -e \"${GREEN}✓ Tailscale 服务已启动${NC}\"\n  else\n    echo -e \"${RED}❌ Tailscale 服务启动失败${NC}\"\n    read -p \"按 Enter 继续...\"\n    return\n  fi\n  \n  echo \"\"\n  echo -e \"${BLUE}🔐 登录 Tailscale...${NC}\"\n  tailscale up\n  \n  echo \"\"\n  echo -e \"${GREEN}==========================================\"\n  echo \"✅ Tailscale 安装和启动完成！\"\n  echo \"==========================================${NC}\"\n  echo \"\"\n  \n  read -p \"按 Enter 继续...\"\n}\n\n# 2. 查看并连接 Exit Node\nconnect_exit_node() {\n  echo -e \"${GREEN}📡 查看可用的 Exit Nodes...${NC}\"\n  echo \"\"\n  \n  # 查看 exit node 列表\n  tailscale exit-node list\n  \n  echo \"\"\n  echo -e \"${YELLOW}可用 Exit Node 列表上方显示${NC}\"\n  echo \"\"\n  read -p \"输入 Exit Node 的 IP 或名称 (或按 Enter 取消): \" exit_node\n  \n  if [ -z \"$exit_node\" ]; then\n    echo \"已取消\"\n    read -p \"按 Enter 继续...\"\n    return\n  fi\n  \n  echo \"\"\n  echo -e \"${BLUE}🔄 连接到 Exit Node: $exit_node${NC}\"\n  sudo tailscale set --exit-node=\"$exit_node\"\n  \n  if [ $? -ne 0 ]; then\n    echo -e \"${RED}❌ 连接失败${NC}\"\n    read -p \"按 Enter 继续...\"\n    return\n  fi\n  \n  echo -e \"${GREEN}✓ Exit Node 连接成功${NC}\"\n  \n  echo \"\"\n  echo -e \"${BLUE}🔍 验证连接...${NC}\"\n  sleep 2\n  \n  echo \"\"\n  echo -e \"${YELLOW}您的公网 IP:${NC}\"\n  external_ip=$(curl -s http://ipv4.icanhazip.com 2>/dev/null)\n  echo \"$external_ip\"\n  \n  echo \"\"\n  echo -e \"${YELLOW}Tailscale 状态:${NC}\"\n  tailscale status | head -10\n  \n  echo \"\"\n  echo -e \"${GREEN}==========================================\"\n  echo \"✅ Exit Node 已连接！\"\n  echo \"==========================================${NC}\"\n  echo \"\"\n  \n  read -p \"按 Enter 继续...\"\n}\n\n# 3. 设置本机为 Exit Node\nset_as_exit_node() {\n  echo -e \"${GREEN}⚙️ 设置本机为 Exit Node...${NC}\"\n  echo \"\"\n  \n  echo -e \"${YELLOW}⚠️ 警告:${NC}\"\n  echo \"  - 这会让其他设备通过本机访问网络\"\n  echo \"  - 确保你了解 Exit Node 的安全含义\"\n  echo \"\"\n  \n  read -p \"确认设置为 Exit Node? (yes/no): \" confirm\n  \n  if [ \"$confirm\" != \"yes\" ]; then\n    echo \"已取消\"\n    read -p \"按 Enter 继续...\"\n    return\n  fi\n  \n  echo \"\"\n  echo -e \"${BLUE}🔄 配置本机为 Exit Node...${NC}\"\n  sudo tailscale set --advertise-exit-node\n  \n  if [ $? -ne 0 ]; then\n    echo -e \"${RED}❌ 配置失败${NC}\"\n    read -p \"按 Enter 继续...\"\n    return\n  fi\n  \n  echo -e \"${GREEN}✓ 本机已设置为 Exit Node${NC}\"\n  \n  echo \"\"\n  echo -e \"${YELLOW}提示:${NC}\"\n  echo \"  - 在 Tailscale 管理界面中可以批准此 Exit Node\"\n  echo \"  - 其他设备可以连接到本机进行出网\"\n  echo \"\"\n  \n  echo -e \"${YELLOW}您的 Tailscale IP:${NC}\"\n  tailscale ip -4\n  \n  echo \"\"\n  read -p \"按 Enter 继续...\"\n}\n\n# 4. 查看 Tailscale 状态\nshow_tailscale_status() {\n  clear\n  echo -e \"${BLUE}==========================================\"\n  echo \"      Tailscale 状态信息\"\n  echo \"==========================================${NC}\"\n  echo \"\"\n  \n  echo -e \"${YELLOW}📊 服务状态:${NC}\"\n  systemctl status tailscaled | grep \"Active\"\n  \n  echo \"\"\n  echo -e \"${YELLOW}🌐 网络状态:${NC}\"\n  tailscale status\n  \n  echo \"\"\n  echo -e \"${YELLOW}📍 Tailscale IP:${NC}\"\n  tailscale ip -4\n  \n  echo \"\"\n  echo -e \"${YELLOW}🔗 Exit Node 信息:${NC}\"\n  tailscale set --help 2>&1 | grep exit-node || echo \"无当前 Exit Node\"\n  \n  echo \"\"\n  echo -e \"${YELLOW}📡 Exit Node 列表:${NC}\"\n  tailscale exit-node list\n  \n  echo \"\"\n  echo -e \"${YELLOW}🔐 当前用户:${NC}\"\n  tailscale whoami\n  \n  echo \"\"\n  echo -e \"${BLUE}=========================================${NC}\"\n  echo \"\"\n  \n  read -p \"按 Enter 继续...\"\n}\n\n# 5. 断开 Exit Node\ndisconnect_exit_node() {\n  echo -e \"${GREEN}🔌 断开 Exit Node...${NC}\"\n  echo \"\"\n  \n  read -p \"确认断开 Exit Node? (yes/no): \" confirm\n  \n  if [ \"$confirm\" != \"yes\" ]; then\n    echo \"已取消\"\n    read -p \"按 Enter 继续...\"\n    return\n  fi\n  \n  echo -e \"${BLUE}🔄 断开中...${NC}\"\n  sudo tailscale set --exit-node=\"\"\n  \n  sleep 2\n  \n  echo -e \"${GREEN}✓ Exit Node 已断开${NC}\"\n  echo \"\"\n  echo -e \"${YELLOW}您的公网 IP:${NC}\"\n  curl -s http://ipv4.icanhazip.com 2>/dev/null || echo \"无法获取\"\n  \n  echo \"\"\n  read -p \"按 Enter 继续...\"\n}\n\n# 6. 卸载 Tailscale\nuninstall_tailscale() {\n  echo -e \"${RED}⚠️ 警告：这将卸载 Tailscale！${NC}\"\n  echo \"\"\n  \n  read -p \"确认卸载? (yes/no): \" confirm\n  \n  if [ \"$confirm\" != \"yes\" ]; then\n    echo \"已取消\"\n    read -p \"按 Enter 继续...\"\n    return\n  fi\n  \n  echo \"\"\n  echo -e \"${BLUE}🧹 卸载 Tailscale...${NC}\"\n  \n  # 停止服务\n  systemctl stop tailscaled 2>/dev/null\n  \n  # 卸载\n  apt-get remove -y tailscale 2>/dev/null\n  apt-get purge -y tailscale 2>/dev/null\n  \n  # 清理配置\n  rm -rf /var/lib/tailscale\n  rm -rf /var/cache/tailscale\n  \n  echo -e \"${GREEN}✓ Tailscale 已卸载${NC}\"\n  echo \"\"\n  \n  read -p \"按 Enter 继续...\"\n}\n\n# 主循环\ncheck_root\n\nwhile true; do\n  show_menu\n  read -p \"请选择 [1-7]: \" choice\n  \n  case $choice in\n    1)\n      install_tailscale\n      ;;\n    2)\n      connect_exit_node\n      ;;\n    3)\n      set_as_exit_node\n      ;;\n    4)\n      show_tailscale_status\n      ;;\n    5)\n      disconnect_exit_node\n      ;;\n    6)\n      uninstall_tailscale\n      ;;\n    7)\n      echo -e \"${GREEN}👋 谢谢使用！再见！${NC}\"\n      exit 0\n      ;;\n    *)\n      echo -e \"${RED}❌ 无效选择，请重试${NC}\"\n      sleep 2\n      ;;\n  esac\ndone",
      "lines": 316,
      "added_time": "2025-12-13T09:23:53Z"
    },
    {
      "id": 6,
      "name": "WIFI  有线管理",
      "content": "#!/bin/bash\n\n# 网络管理工具\n# 功能：WIFI 和有线网络完整管理\n\n# 配置文件\nCONFIG_FILE=\"/etc/wifi-config.conf\"\nTEMP_FILE=\"/tmp/wifi-temp.conf\"\n\n# 颜色定义\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nBLUE='\\033[0;34m'\nCYAN='\\033[0;36m'\nMAGENTA='\\033[0;35m'\nNC='\\033[0m' # No Color\n\n# 常用DNS服务器\ndeclare -A DNS_SERVERS=(\n    [\"Google\"]=\"8.8.8.8,8.8.4.4\"\n    [\"Cloudflare\"]=\"1.1.1.1,1.0.0.1\"\n    [\"阿里云\"]=\"223.5.5.5,223.6.6.6\"\n    [\"腾讯云\"]=\"119.29.29.29,182.254.116.116\"\n    [\"114DNS\"]=\"114.114.114.114,114.114.115.115\"\n    [\"OpenDNS\"]=\"208.67.222.222,208.67.220.220\"\n)\n\n# 检查是否为 root\ncheck_root() {\n    if [[ $EUID -ne 0 ]]; then\n        echo -e \"${RED}错误：此脚本需要 root 权限运行${NC}\"\n        echo -e \"${YELLOW}请使用: sudo $0${NC}\"\n        exit 1\n    fi\n}\n\n# 初始化配置文件\ninit_config() {\n    if [ ! -f \"$CONFIG_FILE\" ]; then\n        touch \"$CONFIG_FILE\"\n        chmod 600 \"$CONFIG_FILE\"\n        echo -e \"${GREEN}✓ 配置文件已创建: $CONFIG_FILE${NC}\"\n    fi\n}\n\n# 获取 WIFI 密码（加密存储为 base64）\nencode_password() {\n    echo -n \"$1\" | base64\n}\n\n# 解密 WIFI 密码\ndecode_password() {\n    echo -n \"$1\" | base64 -d\n}\n\n# 获取公网IP\nget_public_ip() {\n    echo -e \"${CYAN}正在获取公网IP...${NC}\"\n    \n    # IPv4\n    local ipv4=$(timeout 5 curl -4 -s ifconfig.me 2>/dev/null || timeout 5 curl -4 -s icanhazip.com 2>/dev/null || echo \"获取失败\")\n    \n    # IPv6\n    local ipv6=$(timeout 5 curl -6 -s ifconfig.me 2>/dev/null || timeout 5 curl -6 -s icanhazip.com 2>/dev/null || echo \"不支持或获取失败\")\n    \n    echo -e \"${GREEN}公网 IPv4:${NC} $ipv4\"\n    echo -e \"${GREEN}公网 IPv6:${NC} $ipv6\"\n    echo \"\"\n}\n\n# 显示当前网络状态（简化版）\nshow_current_status() {\n    # 检查当前活动连接\n    local active_wifi=$(nmcli -t -f active,ssid dev wifi | grep \"^yes\" | cut -d: -f2)\n    local active_ethernet=$(nmcli -t -f DEVICE,TYPE,STATE device | grep \"ethernet:connected\" | cut -d: -f1)\n    \n    if [ -n \"$active_wifi\" ]; then\n        echo -e \"${GREEN}当前连接: WIFI ($active_wifi)${NC}\"\n    elif [ -n \"$active_ethernet\" ]; then\n        echo -e \"${GREEN}当前连接: 有线网络 ($active_ethernet)${NC}\"\n    else\n        echo -e \"${YELLOW}当前状态: 未连接网络${NC}\"\n    fi\n}\n\n# ==================== WIFI 管理功能 ====================\n\n# 添加/编辑 WIFI 配置（优化版：从扫描列表选择）\nadd_wifi() {\n    clear\n    echo -e \"${BLUE}╔════════════════════════════════════════╗${NC}\"\n    echo -e \"${BLUE}║         添加 WIFI 配置                  ║${NC}\"\n    echo -e \"${BLUE}╚════════════════════════════════════════╝${NC}\"\n    echo \"\"\n    \n    # 自动扫描 WIFI\n    echo -e \"${CYAN}正在扫描附近的 WIFI...（约 5 秒）${NC}\"\n    \n    local wifi_device=$(nmcli device | grep wifi | awk '{print $1}')\n    \n    if [ -z \"$wifi_device\" ]; then\n        echo -e \"${RED}✗ 未找到 WIFI 设备${NC}\"\n        return 1\n    fi\n    \n    # 扫描 WIFI\n    nmcli dev wifi rescan 2>/dev/null\n    \n    # 显示扫描进度\n    for i in {1..5}; do\n        echo -ne \"\\r扫描进度: $i/5 秒\"\n        sleep 1\n    done\n    echo -ne \"\\r扫描完成！                \\n\"\n    echo \"\"\n    \n    # 显示扫描结果\n    echo -e \"${GREEN}扫描到的 WIFI 列表：${NC}\"\n    echo \"\"\n    \n    # 保存 WIFI 列表到临时数组\n    local wifi_list=()\n    while IFS= read -r line; do\n        wifi_list+=(\"$line\")\n    done < <(nmcli -t -f SSID,SIGNAL,SECURITY dev wifi list | grep -v \"^--\" | grep -v \"^$\")\n    \n    if [ ${#wifi_list[@]} -eq 0 ]; then\n        echo -e \"${RED}✗ 未扫描到任何 WIFI${NC}\"\n        return 1\n    fi\n    \n    # 显示 WIFI 列表\n    echo -e \"${CYAN}编号  SSID                              信号    安全${NC}\"\n    echo \"────────────────────────────────────────────────────────────\"\n    \n    local index=1\n    for wifi in \"${wifi_list[@]}\"; do\n        IFS=':' read -r ssid signal security <<< \"$wifi\"\n        printf \"${GREEN}%-4s${NC}  %-35s %-6s  %s\\n\" \"$index\" \"$ssid\" \"$signal\" \"$security\"\n        ((index++))\n    done\n    \n    echo \"\"\n    echo -e \"${YELLOW}提示: 输入 0 可手动输入 SSID（适用于隐藏网络）${NC}\"\n    echo \"\"\n    \n    # 用户选择\n    read -p \"请选择要添加的 WIFI (输入编号): \" choice\n    \n    local selected_ssid=\"\"\n    \n    if [ \"$choice\" = \"0\" ]; then\n        # 手动输入模式\n        read -p \"请输入 WIFI 名称 (SSID): \" selected_ssid\n        if [ -z \"$selected_ssid\" ]; then\n            echo -e \"${RED}✗ WIFI 名称不能为空${NC}\"\n            return 1\n        fi\n    elif [[ \"$choice\" =~ ^[0-9]+$ ]] && [ \"$choice\" -ge 1 ] && [ \"$choice\" -le ${#wifi_list[@]} ]; then\n        # 从列表选择\n        local selected_wifi=\"${wifi_list[$((choice-1))]}\"\n        selected_ssid=$(echo \"$selected_wifi\" | cut -d: -f1)\n    else\n        echo -e \"${RED}✗ 无效的选择${NC}\"\n        return 1\n    fi\n    \n    echo \"\"\n    echo -e \"${CYAN}已选择 WIFI: $selected_ssid${NC}\"\n    echo \"\"\n    \n    # 输入密码\n    read -sp \"请输入 WIFI 密码: \" password\n    echo \"\"\n    read -sp \"请重新输入密码确认: \" password_confirm\n    echo \"\"\n    \n    if [ \"$password\" != \"$password_confirm\" ]; then\n        echo -e \"${RED}✗ 两次密码不一致${NC}\"\n        return 1\n    fi\n    \n    # 检查是否已存在\n    if grep -q \"^$selected_ssid|\" \"$CONFIG_FILE\"; then\n        echo -e \"${YELLOW}⚠ WIFI 已存在，将进行覆盖${NC}\"\n        sed -i \"/^$selected_ssid|/d\" \"$CONFIG_FILE\"\n    fi\n    \n    # 加密密码并保存\n    encoded_password=$(encode_password \"$password\")\n    echo \"$selected_ssid|$encoded_password\" >> \"$CONFIG_FILE\"\n    \n    echo -e \"${GREEN}✓ WIFI 配置已保存${NC}\"\n    return 0\n}\n\n# 显示已保存的 WIFI 列表\nlist_wifi() {\n    if [ ! -s \"$CONFIG_FILE\" ]; then\n        echo -e \"${YELLOW}⚠ 没有已保存的 WIFI 配置${NC}\"\n        return 1\n    fi\n    \n    echo -e \"${CYAN}已保存的 WIFI 列表：${NC}\"\n    local count=0\n    while IFS='|' read -r ssid password; do\n        count=$((count + 1))\n        echo -e \"  ${GREEN}$count${NC}. $ssid\"\n    done < \"$CONFIG_FILE\"\n    \n    return 0\n}\n\n# 连接已保存的 WIFI\nconnect_saved_wifi() {\n    clear\n    echo -e \"${BLUE}╔════════════════════════════════════════╗${NC}\"\n    echo -e \"${BLUE}║         连接已保存的 WIFI               ║${NC}\"\n    echo -e \"${BLUE}╚════════════════════════════════════════╝${NC}\"\n    echo \"\"\n    \n    if ! list_wifi; then\n        return 1\n    fi\n    \n    echo \"\"\n    read -p \"请选择要连接的 WIFI (输入序号): \" choice\n    \n    # 获取选中的 WIFI 信息\n    local count=0\n    local selected_ssid=\"\"\n    local selected_password=\"\"\n    \n    while IFS='|' read -r ssid password; do\n        count=$((count + 1))\n        if [ \"$count\" -eq \"$choice\" ]; then\n            selected_ssid=\"$ssid\"\n            selected_password=$(decode_password \"$password\")\n            break\n        fi\n    done < \"$CONFIG_FILE\"\n    \n    if [ -z \"$selected_ssid\" ]; then\n        echo -e \"${RED}✗ 无效的选择${NC}\"\n        return 1\n    fi\n    \n    echo -e \"${CYAN}正在连接到: $selected_ssid${NC}\"\n    \n    # 使用 nmcli 连接 WIFI\n    nmcli dev wifi connect \"$selected_ssid\" password \"$selected_password\"\n    \n    if [ $? -eq 0 ]; then\n        echo -e \"${GREEN}✓ 已连接到: $selected_ssid${NC}\"\n        return 0\n    else\n        echo -e \"${RED}✗ 连接失败，请检查密码或信号${NC}\"\n        return 1\n    fi\n}\n\n# 扫描附近 WIFI（仅查看）\nscan_wifi() {\n    clear\n    echo -e \"${BLUE}╔════════════════════════════════════════╗${NC}\"\n    echo -e \"${BLUE}║         扫描附近的 WIFI                 ║${NC}\"\n    echo -e \"${BLUE}╚════════════════════════════════════════╝${NC}\"\n    echo \"\"\n    \n    echo -e \"${CYAN}正在扫描所有 WIFI 信号...（约 5 秒）${NC}\"\n    \n    local wifi_device=$(nmcli device | grep wifi | awk '{print $1}')\n    \n    if [ -z \"$wifi_device\" ]; then\n        echo -e \"${RED}✗ 未找到 WIFI 设备${NC}\"\n        return 1\n    fi\n    \n    nmcli dev wifi rescan 2>/dev/null\n    \n    for i in {1..5}; do\n        echo -ne \"\\r扫描进度: $i/5 秒\"\n        sleep 1\n    done\n    echo -ne \"\\r扫描完成！                \\n\"\n    echo \"\"\n    \n    echo -e \"${GREEN}扫描结果：${NC}\"\n    echo \"\"\n    nmcli dev wifi list 2>/dev/null | head -50\n    \n    echo \"\"\n    local total=$(nmcli dev wifi list 2>/dev/null | wc -l)\n    echo -e \"${YELLOW}总共找到 $((total-1)) 个 WIFI 网络${NC}\"\n}\n\n# 删除 WIFI 配置\ndelete_wifi() {\n    clear\n    echo -e \"${BLUE}╔════════════════════════════════════════╗${NC}\"\n    echo -e \"${BLUE}║         删除 WIFI 配置                  ║${NC}\"\n    echo -e \"${BLUE}╚════════════════════════════════════════╝${NC}\"\n    echo \"\"\n    \n    if ! list_wifi; then\n        return 1\n    fi\n    \n    echo \"\"\n    read -p \"请选择要删除的 WIFI (输入序号): \" choice\n    \n    local count=0\n    local selected_ssid=\"\"\n    \n    while IFS='|' read -r ssid password; do\n        count=$((count + 1))\n        if [ \"$count\" -eq \"$choice\" ]; then\n            selected_ssid=\"$ssid\"\n            break\n        fi\n    done < \"$CONFIG_FILE\"\n    \n    if [ -z \"$selected_ssid\" ]; then\n        echo -e \"${RED}✗ 无效的选择${NC}\"\n        return 1\n    fi\n    \n    read -p \"确认删除 '$selected_ssid' 吗? (y/n): \" confirm\n    if [ \"$confirm\" != \"y\" ] && [ \"$confirm\" != \"Y\" ]; then\n        echo -e \"${YELLOW}⚠ 已取消${NC}\"\n        return 0\n    fi\n    \n    sed -i \"/^${selected_ssid}|/d\" \"$CONFIG_FILE\"\n    echo -e \"${GREEN}✓ WIFI 配置已删除${NC}\"\n}\n\n# WIFI 管理菜单\nwifi_menu() {\n    while true; do\n        clear\n        echo -e \"${BLUE}╔════════════════════════════════════════╗${NC}\"\n        echo -e \"${BLUE}║           WIFI 管理菜单                 ║${NC}\"\n        echo -e \"${BLUE}╚════════════════════════════════════════╝${NC}\"\n        echo \"\"\n        show_current_status\n        echo \"\"\n        echo -e \"${YELLOW}请选择操作:${NC}\"\n        echo -e \"  ${GREEN}1${NC}) 添加/编辑 WIFI 配置\"\n        echo -e \"  ${GREEN}2${NC}) 连接已保存的 WIFI\"\n        echo -e \"  ${GREEN}3${NC}) 扫描附近的 WIFI\"\n        echo -e \"  ${GREEN}4${NC}) 删除 WIFI 配置\"\n        echo -e \"  ${GREEN}0${NC}) 返回主菜单\"\n        echo \"\"\n        read -p \"请输入选项: \" choice\n        \n        case $choice in\n            1) add_wifi ;;\n            2) connect_saved_wifi ;;\n            3) scan_wifi ;;\n            4) delete_wifi ;;\n            0) return 0 ;;\n            *) echo -e \"${RED}无效的选项${NC}\" ;;\n        esac\n        \n        read -p \"按 Enter 继续...\"\n    done\n}\n\n# ==================== 有线网络管理功能 ====================\n\n# 查看有线网络状态\nshow_ethernet_status() {\n    clear\n    echo -e \"${BLUE}╔════════════════════════════════════════╗${NC}\"\n    echo -e \"${BLUE}║         有线网络状态                    ║${NC}\"\n    echo -e \"${BLUE}╚════════════════════════════════════════╝${NC}\"\n    echo \"\"\n    \n    # 显示所有以太网设备\n    echo -e \"${CYAN}=== 有线网络接口 ===${NC}\"\n    nmcli device | grep ethernet | awk '{printf \"%-15s %-12s %-15s %s\\n\", $1, $2, $3, $4}'\n    echo \"\"\n    \n    # 显示虚拟网络接口\n    echo -e \"${CYAN}=== 虚拟网络接口 ===${NC}\"\n    ip link show | grep -E \"docker|veth|br-|virbr\" | awk '{print $2}' | sed 's/:$//' | while read iface; do\n        echo \"  • $iface\"\n    done\n    echo \"\"\n    \n    # 显示详细的活动连接\n    echo -e \"${CYAN}=== 活动的有线连接详情 ===${NC}\"\n    nmcli connection show --active | grep ethernet | while read line; do\n        local conn_name=$(echo \"$line\" | awk '{print $1}')\n        echo -e \"${GREEN}连接名称:${NC} $conn_name\"\n        \n        nmcli connection show \"$conn_name\" 2>/dev/null | grep -E \"IP4.ADDRESS|IP4.GATEWAY|IP4.DNS|IP6.ADDRESS|GENERAL.HWADDR\" | while read detail; do\n            echo \"  $detail\"\n        done\n        echo \"\"\n    done\n    \n    # 显示公网IP\n    echo -e \"${CYAN}=== 公网 IP 地址 ===${NC}\"\n    get_public_ip\n}\n\n# 配置有线网络DNS\nconfigure_ethernet_dns() {\n    clear\n    echo -e \"${BLUE}╔════════════════════════════════════════╗${NC}\"\n    echo -e \"${BLUE}║         配置有线网络 DNS                ║${NC}\"\n    echo -e \"${BLUE}╚════════════════════════════════════════╝${NC}\"\n    echo \"\"\n    \n    # 获取有线连接列表\n    local eth_connections=($(nmcli -t -f NAME,TYPE connection show | grep ethernet | cut -d: -f1))\n    \n    if [ ${#eth_connections[@]} -eq 0 ]; then\n        echo -e \"${RED}✗ 未找到有线网络连接${NC}\"\n        return 1\n    fi\n    \n    # 显示连接列表\n    echo -e \"${CYAN}有线网络连接列表：${NC}\"\n    for i in \"${!eth_connections[@]}\"; do\n        echo -e \"  ${GREEN}$((i+1))${NC}) ${eth_connections[$i]}\"\n    done\n    echo \"\"\n    \n    read -p \"请选择要配置的连接 (输入序号): \" conn_choice\n    \n    if [[ ! \"$conn_choice\" =~ ^[0-9]+$ ]] || [ \"$conn_choice\" -lt 1 ] || [ \"$conn_choice\" -gt ${#eth_connections[@]} ]; then\n        echo -e \"${RED}✗ 无效的选择${NC}\"\n        return 1\n    fi\n    \n    local selected_conn=\"${eth_connections[$((conn_choice-1))]}\"\n    echo -e \"${CYAN}已选择连接: $selected_conn${NC}\"\n    echo \"\"\n    \n    # 显示预设DNS\n    echo -e \"${YELLOW}请选择 DNS 服务器：${NC}\"\n    local dns_index=1\n    local dns_keys=()\n    \n    for dns_name in \"${!DNS_SERVERS[@]}\"; do\n        dns_keys+=(\"$dns_name\")\n        echo -e \"  ${GREEN}$dns_index${NC}) $dns_name (${DNS_SERVERS[$dns_name]})\"\n        ((dns_index++))\n    done\n    echo -e \"  ${GREEN}0${NC}) 手动输入 DNS\"\n    echo \"\"\n    \n    read -p \"请选择 (输入序号): \" dns_choice\n    \n    local dns_servers=\"\"\n    \n    if [ \"$dns_choice\" = \"0\" ]; then\n        read -p \"请输入 DNS 服务器 (多个用逗号分隔): \" dns_servers\n    elif [[ \"$dns_choice\" =~ ^[0-9]+$ ]] && [ \"$dns_choice\" -ge 1 ] && [ \"$dns_choice\" -le ${#dns_keys[@]} ]; then\n        local selected_dns_name=\"${dns_keys[$((dns_choice-1))]}\"\n        dns_servers=\"${DNS_SERVERS[$selected_dns_name]}\"\n    else\n        echo -e \"${RED}✗ 无效的选择${NC}\"\n        return 1\n    fi\n    \n    echo \"\"\n    echo -e \"${CYAN}正在设置 DNS: $dns_servers${NC}\"\n    \n    # 设置DNS\n    nmcli connection modify \"$selected_conn\" ipv4.dns \"$dns_servers\"\n    nmcli connection modify \"$selected_conn\" ipv4.ignore-auto-dns yes\n    nmcli connection up \"$selected_conn\"\n    \n    if [ $? -eq 0 ]; then\n        echo -e \"${GREEN}✓ DNS 设置成功${NC}\"\n    else\n        echo -e \"${RED}✗ DNS 设置失败${NC}\"\n    fi\n}\n\n# 配置有线网络网关和IP\nconfigure_ethernet_ip() {\n    clear\n    echo -e \"${BLUE}╔════════════════════════════════════════╗${NC}\"\n    echo -e \"${BLUE}║         配置有线网络 IP/网关            ║${NC}\"\n    echo -e \"${BLUE}╚════════════════════════════════════════╝${NC}\"\n    echo \"\"\n    \n    # 获取有线连接列表\n    local eth_connections=($(nmcli -t -f NAME,TYPE connection show | grep ethernet | cut -d: -f1))\n    \n    if [ ${#eth_connections[@]} -eq 0 ]; then\n        echo -e \"${RED}✗ 未找到有线网络连接${NC}\"\n        return 1\n    fi\n    \n    # 显示连接列表\n    echo -e \"${CYAN}有线网络连接列表：${NC}\"\n    for i in \"${!eth_connections[@]}\"; do\n        echo -e \"  ${GREEN}$((i+1))${NC}) ${eth_connections[$i]}\"\n    done\n    echo \"\"\n    \n    read -p \"请选择要配置的连接 (输入序号): \" conn_choice\n    \n    if [[ ! \"$conn_choice\" =~ ^[0-9]+$ ]] || [ \"$conn_choice\" -lt 1 ] || [ \"$conn_choice\" -gt ${#eth_connections[@]} ]; then\n        echo -e \"${RED}✗ 无效的选择${NC}\"\n        return 1\n    fi\n    \n    local selected_conn=\"${eth_connections[$((conn_choice-1))]}\"\n    echo -e \"${CYAN}已选择连接: $selected_conn${NC}\"\n    echo \"\"\n    \n    # 选择配置模式\n    echo -e \"${YELLOW}请选择配置模式：${NC}\"\n    echo -e \"  ${GREEN}1${NC}) DHCP (自动获取)\"\n    echo -e \"  ${GREEN}2${NC}) 静态 IP\"\n    echo \"\"\n    read -p \"请选择: \" mode_choice\n    \n    if [ \"$mode_choice\" = \"1\" ]; then\n        # DHCP 模式\n        echo -e \"${CYAN}正在设置为 DHCP 模式...${NC}\"\n        nmcli connection modify \"$selected_conn\" ipv4.method auto\n        nmcli connection up \"$selected_conn\"\n        echo -e \"${GREEN}✓ 已切换到 DHCP 模式${NC}\"\n        \n    elif [ \"$mode_choice\" = \"2\" ]; then\n        # 静态 IP 模式\n        echo \"\"\n        read -p \"请输入 IP 地址 (如: 192.168.1.100): \" ip_addr\n        read -p \"请输入子网掩码位数 (如: 24): \" prefix\n        read -p \"请输入网关地址 (如: 192.168.1.1): \" gateway\n        \n        if [ -z \"$ip_addr\" ] || [ -z \"$prefix\" ] || [ -z \"$gateway\" ]; then\n            echo -e \"${RED}✗ 信息不完整${NC}\"\n            return 1\n        fi\n        \n        echo \"\"\n        echo -e \"${CYAN}正在设置静态 IP...${NC}\"\n        nmcli connection modify \"$selected_conn\" ipv4.method manual\n        nmcli connection modify \"$selected_conn\" ipv4.addresses \"$ip_addr/$prefix\"\n        nmcli connection modify \"$selected_conn\" ipv4.gateway \"$gateway\"\n        nmcli connection up \"$selected_conn\"\n        \n        echo -e \"${GREEN}✓ 静态 IP 设置成功${NC}\"\n        echo -e \"  IP: $ip_addr/$prefix\"\n        echo -e \"  网关: $gateway\"\n    else\n        echo -e \"${RED}✗ 无效的选择${NC}\"\n        return 1\n    fi\n}\n\n# 启用/禁用有线网络\ntoggle_ethernet() {\n    clear\n    echo -e \"${BLUE}╔════════════════════════════════════════╗${NC}\"\n    echo -e \"${BLUE}║         启用/禁用有线网络               ║${NC}\"\n    echo -e \"${BLUE}╚════════════════════════════════════════╝${NC}\"\n    echo \"\"\n    \n    # 获取所有以太网设备\n    echo -e \"${CYAN}有线网络设备列表：${NC}\"\n    local eth_devices=($(nmcli -t -f DEVICE,TYPE device | grep ethernet | cut -d: -f1))\n    \n    if [ ${#eth_devices[@]} -eq 0 ]; then\n        echo -e \"${RED}✗ 未找到有线网络设备${NC}\"\n        return 1\n    fi\n    \n    for i in \"${!eth_devices[@]}\"; do\n        local device=\"${eth_devices[$i]}\"\n        local state=$(nmcli -t -f DEVICE,STATE device | grep \"^$device:\" | cut -d: -f2)\n        echo -e \"  ${GREEN}$((i+1))${NC}) $device [$state]\"\n    done\n    echo \"\"\n    \n    read -p \"请选择设备 (输入序号): \" dev_choice\n    \n    if [[ ! \"$dev_choice\" =~ ^[0-9]+$ ]] || [ \"$dev_choice\" -lt 1 ] || [ \"$dev_choice\" -gt ${#eth_devices[@]} ]; then\n        echo -e \"${RED}✗ 无效的选择${NC}\"\n        return 1\n    fi\n    \n    local selected_device=\"${eth_devices[$((dev_choice-1))]}\"\n    local current_state=$(nmcli -t -f DEVICE,STATE device | grep \"^$selected_device:\" | cut -d: -f2)\n    \n    echo \"\"\n    echo -e \"${YELLOW}请选择操作：${NC}\"\n    echo -e \"  ${GREEN}1${NC}) 启用\"\n    echo -e \"  ${GREEN}2${NC}) 禁用\"\n    echo \"\"\n    read -p \"请选择: \" action\n    \n    if [ \"$action\" = \"1\" ]; then\n        nmcli device connect \"$selected_device\"\n        echo -e \"${GREEN}✓ 已启用 $selected_device${NC}\"\n    elif [ \"$action\" = \"2\" ]; then\n        nmcli device disconnect \"$selected_device\"\n        echo -e \"${GREEN}✓ 已禁用 $selected_device${NC}\"\n    else\n        echo -e \"${RED}✗ 无效的选择${NC}\"\n    fi\n}\n\n# 有线网络管理菜单\nethernet_menu() {\n    while true; do\n        clear\n        echo -e \"${BLUE}╔════════════════════════════════════════╗${NC}\"\n        echo -e \"${BLUE}║         有线网络管理菜单                ║${NC}\"\n        echo -e \"${BLUE}╚════════════════════════════════════════╝${NC}\"\n        echo \"\"\n        show_current_status\n        echo \"\"\n        echo -e \"${YELLOW}请选择操作:${NC}\"\n        echo -e \"  ${GREEN}1${NC}) 查看有线网络状态\"\n        echo -e \"  ${GREEN}2${NC}) 配置 DNS 服务器\"\n        echo -e \"  ${GREEN}3${NC}) 配置 IP 地址和网关\"\n        echo -e \"  ${GREEN}4${NC}) 启用/禁用有线网络\"\n        echo -e \"  ${GREEN}0${NC}) 返回主菜单\"\n        echo \"\"\n        read -p \"请输入选项: \" choice\n        \n        case $choice in\n            1) show_ethernet_status ;;\n            2) configure_ethernet_dns ;;\n            3) configure_ethernet_ip ;;\n            4) toggle_ethernet ;;\n            0) return 0 ;;\n            *) echo -e \"${RED}无效的选项${NC}\" ;;\n        esac\n        \n        read -p \"按 Enter 继续...\"\n    done\n}\n\n# ==================== 网络切换功能 ====================\n\n# 切换到有线网络\nswitch_to_ethernet() {\n    clear\n    echo -e \"${BLUE}╔════════════════════════════════════════╗${NC}\"\n    echo -e \"${BLUE}║         切换到有线网络                  ║${NC}\"\n    echo -e \"${BLUE}╚════════════════════════════════════════╝${NC}\"\n    echo \"\"\n    \n    echo -e \"${YELLOW}警告: 此操作将禁用所有 WIFI 连接${NC}\"\n    read -p \"确认切换到有线网络吗? (y/n): \" confirm\n    \n    if [ \"$confirm\" != \"y\" ] && [ \"$confirm\" != \"Y\" ]; then\n        echo -e \"${YELLOW}⚠ 已取消${NC}\"\n        return 0\n    fi\n    \n    echo \"\"\n    echo -e \"${CYAN}正在禁用 WIFI...${NC}\"\n    nmcli radio wifi off\n    \n    sleep 1\n    \n    echo -e \"${CYAN}正在启用有线网络...${NC}\"\n    local eth_devices=($(nmcli -t -f DEVICE,TYPE device | grep ethernet | cut -d: -f1))\n    \n    for device in \"${eth_devices[@]}\"; do\n        nmcli device connect \"$device\" 2>/dev/null\n    done\n    \n    sleep 1\n    \n    echo -e \"${GREEN}✓ 已切换到有线网络${NC}\"\n    echo \"\"\n    \n    # 显示当前连接状态\n    echo -e \"${CYAN}当前网络状态：${NC}\"\n    nmcli device | grep -E \"ethernet|wifi\"\n}\n\n# 切换到 WIFI 网络\nswitch_to_wifi() {\n    clear\n    echo -e \"${BLUE}╔════════════════════════════════════════╗${NC}\"\n    echo -e \"${BLUE}║         切换到 WIFI 网络                ║${NC}\"\n    echo -e \"${BLUE}╚════════════════════════════════════════╝${NC}\"\n    echo \"\"\n    \n    echo -e \"${YELLOW}警告: 此操作将禁用所有有线网络连接${NC}\"\n    read -p \"确认切换到 WIFI 网络吗? (y/n): \" confirm\n    \n    if [ \"$confirm\" != \"y\" ] && [ \"$confirm\" != \"Y\" ]; then\n        echo -e \"${YELLOW}⚠ 已取消${NC}\"\n        return 0\n    fi\n    \n    echo \"\"\n    echo -e \"${CYAN}正在禁用有线网络...${NC}\"\n    local eth_devices=($(nmcli -t -f DEVICE,TYPE device | grep ethernet | cut -d: -f1))\n    \n    for device in \"${eth_devices[@]}\"; do\n        nmcli device disconnect \"$device\" 2>/dev/null\n    done\n    \n    sleep 1\n    \n    echo -e \"${CYAN}正在启用 WIFI...${NC}\"\n    nmcli radio wifi on\n    \n    sleep 2\n    \n    echo -e \"${GREEN}✓ 已切换到 WIFI 模式${NC}\"\n    echo \"\"\n    \n    # 检查是否有保存的 WIFI\n    if [ -s \"$CONFIG_FILE\" ]; then\n        echo -e \"${CYAN}是否要连接已保存的 WIFI? (y/n): ${NC}\"\n        read connect_choice\n        if [ \"$connect_choice\" = \"y\" ] || [ \"$connect_choice\" = \"Y\" ]; then\n            connect_saved_wifi\n            return\n        fi\n    fi\n    \n    # 显示当前状态\n    echo -e \"${CYAN}当前网络状态：${NC}\"\n    nmcli device | grep -E \"ethernet|wifi\"\n}\n\n# 网络切换菜单\nswitch_menu() {\n    while true; do\n        clear\n        echo -e \"${BLUE}╔════════════════════════════════════════╗${NC}\"\n        echo -e \"${BLUE}║           网络切换菜单                  ║${NC}\"\n        echo -e \"${BLUE}╚════════════════════════════════════════╝${NC}\"\n        echo \"\"\n        show_current_status\n        echo \"\"\n        echo -e \"${YELLOW}请选择操作:${NC}\"\n        echo -e \"  ${GREEN}1${NC}) 切换到有线网络 (禁用WIFI)\"\n        echo -e \"  ${GREEN}2${NC}) 切换到 WIFI 网络 (禁用有线)\"\n        echo -e \"  ${GREEN}0${NC}) 返回主菜单\"\n        echo \"\"\n        read -p \"请输入选项: \" choice\n        \n        case $choice in\n            1) switch_to_ethernet ;;\n            2) switch_to_wifi ;;\n            0) return 0 ;;\n            *) echo -e \"${RED}无效的选项${NC}\" ;;\n        esac\n        \n        read -p \"按 Enter 继续...\"\n    done\n}\n\n# ==================== 综合状态查看 ====================\n\n# 显示完整的网络状态\nshow_full_status() {\n    clear\n    echo -e \"${BLUE}╔════════════════════════════════════════╗${NC}\"\n    echo -e \"${BLUE}║         综合网络状态                    ║${NC}\"\n    echo -e \"${BLUE}╚════════════════════════════════════════╝${NC}\"\n    echo \"\"\n    \n    # 所有网络设备\n    echo -e \"${CYAN}=== 所有网络设备 ===${NC}\"\n    nmcli device\n    echo \"\"\n    \n    # 活动连接\n    echo -e \"${CYAN}=== 活动连接 ===${NC}\"\n    nmcli connection show --active\n    echo \"\"\n    \n    # WIFI 状态\n    echo -e \"${CYAN}=== WIFI 状态 ===${NC}\"\n    local wifi_status=$(nmcli radio wifi)\n    echo -e \"WIFI 开关: $wifi_status\"\n    \n    local current_wifi=$(nmcli -t -f active,ssid dev wifi | grep \"^yes\" | cut -d: -f2)\n    if [ -n \"$current_wifi\" ]; then\n        echo -e \"${GREEN}当前连接: $current_wifi${NC}\"\n        local signal=$(nmcli -f IN-USE,SSID,SIGNAL dev wifi list | grep \"\\*\" | awk '{print $NF}')\n        echo -e \"信号强度: $signal\"\n    else\n        echo -e \"${YELLOW}未连接 WIFI${NC}\"\n    fi\n    echo \"\"\n    \n    # 有线网络状态\n    echo -e \"${CYAN}=== 有线网络状态 ===${NC}\"\n    nmcli device | grep ethernet\n    echo \"\"\n    \n    # 虚拟网络接口\n    echo -e \"${CYAN}=== 虚拟网络接口 ===${NC}\"\n    ip link show | grep -E \"docker|veth|br-|virbr\" | awk '{print \"  • \" $2}' | sed 's/:$//'\n    echo \"\"\n    \n    # IP 地址\n    echo -e \"${CYAN}=== IP 地址配置 ===${NC}\"\n    ip -4 addr show | grep -E \"inet \" | grep -v \"127.0.0.1\" | awk '{print \"  IPv4: \" $2 \" (\" $(NF) \")\"}'\n    ip -6 addr show | grep -E \"inet6\" | grep -v \"::1\" | grep -v \"fe80\" | awk '{print \"  IPv6: \" $2 \" (\" $(NF) \")\"}'\n    echo \"\"\n    \n    # DNS 配置\n    echo -e \"${CYAN}=== DNS 配置 ===${NC}\"\n    if [ -f /etc/resolv.conf ]; then\n        grep \"^nameserver\" /etc/resolv.conf | awk '{print \"  • \" $2}'\n    fi\n    echo \"\"\n    \n    # 路由表\n    echo -e \"${CYAN}=== 默认路由 ===${NC}\"\n    ip route | grep default\n    echo \"\"\n    \n    # 公网 IP\n    echo -e \"${CYAN}=== 公网 IP ===${NC}\"\n    get_public_ip\n}\n\n# ==================== 主菜单 ====================\n\n# 显示主菜单\nshow_main_menu() {\n    clear\n    echo -e \"${BLUE}╔════════════════════════════════════════╗${NC}\"\n    echo -e \"${BLUE}║          网络管理工具                   ║${NC}\"\n    echo -e \"${BLUE}║    WIFI 和有线网络完整管理              ║${NC}\"\n    echo -e \"${BLUE}╚════════════════════════════════════════╝${NC}\"\n    echo \"\"\n    show_current_status\n    echo \"\"\n    echo -e \"${YELLOW}请选择功能模块:${NC}\"\n    echo -e \"  ${GREEN}1${NC}) WIFI 管理\"\n    echo -e \"  ${GREEN}2${NC}) 有线网络管理\"\n    echo -e \"  ${GREEN}3${NC}) 网络切换\"\n    echo -e \"  ${GREEN}4${NC}) 综合状态查看\"\n    echo -e \"  ${GREEN}5${NC}) 退出\"\n    echo \"\"\n}\n\n# 主程序\nmain() {\n    check_root\n    init_config\n    \n    while true; do\n        show_main_menu\n        read -p \"请输入选项 (1-5): \" choice\n        \n        case $choice in\n            1)\n                wifi_menu\n                ;;\n            2)\n                ethernet_menu\n                ;;\n            3)\n                switch_menu\n                ;;\n            4)\n                show_full_status\n                read -p \"按 Enter 返回主菜单...\"\n                ;;\n            5)\n                echo -e \"${BLUE}感谢使用网络管理工具！${NC}\"\n                exit 0\n                ;;\n            *)\n                echo -e \"${RED}无效的选项，请重新选择${NC}\"\n                sleep 1\n                ;;\n        esac\n    done\n}\n\n# 运行主程序\nmain",
      "lines": 888,
      "added_time": "2025-12-14T02:33:55Z"
    }
  ]
}
