#!/bin/bash

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# 权限检查
if [ "$EUID" -ne 0 ]; then 
  echo -e "${RED}错误：请使用 root 权限运行此脚本（sudo ./vps_fix.sh）。${NC}"
  exit 1
fi

# 菜单显示
show_menu() {
    clear
    echo -e "${BLUE}================================================${NC}"
    echo -e "${GREEN}       甲骨文 VPS 资源管理与服务优化工具          ${NC}"
    echo -e "${BLUE}================================================${NC}"
    echo -e "${YELLOW}1.${NC} 检查内存、Swap 及僵尸进程状态"
    echo -e "${YELLOW}2.${NC} 一键创建/重置 2GB 虚拟内存 (Swap)"
    echo -e "${YELLOW}3.${NC} 清理僵尸进程 (自动杀掉制造者的父进程)"
    echo -e "${YELLOW}4.${NC} 资源消耗排榜 (前20/支持多选/注销服务)"
    echo -e "${YELLOW}5.${NC} 限制 Docker 容器内存 (动态选择容器)"
    echo -e "${YELLOW}6.${NC} 彻底屏蔽系统服务 (手动输入名)"
    echo -e "${YELLOW}0.${NC} 退出脚本"
    echo -e "${BLUE}================================================${NC}"
    echo -n "请输入选项 [0-6]: "
}

# 1. 检查状态
check_status() {
    echo -e "${GREEN}--- 内存使用详情 ---${NC}"
    free -h
    echo -e "\n${GREEN}--- 僵尸进程统计 ---${NC}"
    zombie_count=$(ps -ef | grep 'defunct' | grep -v grep | wc -l)
    if [ "$zombie_count" -gt 0 ]; then
        echo -e "${RED}当前发现 $zombie_count 个僵尸进程！${NC}"
        ps -ef | grep 'defunct' | grep -v grep
    else
        echo -e "${GREEN}暂无僵尸进程，系统洁净。${NC}"
    fi
}

# 2. 创建 Swap
make_swap() {
    echo -e "${YELLOW}正在配置 2GB 虚拟内存...${NC}"
    if [ -f /swapfile ]; then
        swapoff /swapfile 2>/dev/null
        rm -f /swapfile
    fi
    fallocate -l 2G /swapfile || dd if=/dev/zero of=/swapfile bs=1M count=2048
    chmod 600 /swapfile
    mkswap /swapfile
    swapon /swapfile
    if ! grep -q "/swapfile" /etc/fstab; then
        echo '/swapfile none swap sw 0 0' >> /etc/fstab
    fi
    echo -e "${GREEN}2GB Swap 已创建并设置为开机自启。${NC}"
}

# 3. 清理僵尸进程
kill_zombies() {
    parents=$(ps -ef | grep 'defunct' | grep -v grep | awk '{print $3}' | sort -u)
    if [ -n "$parents" ]; then
        for ppid in $parents; do
            if [ "$ppid" -ne 1 ]; then
                proc_name=$(ps -p $ppid -o comm=)
                echo -e "${RED}发现僵尸制造者: $proc_name (PID: $ppid)，正在清理...${NC}"
                kill -9 $ppid
            fi
        done
        echo -e "${GREEN}清理完成。${NC}"
    else
        echo -e "${GREEN}未发现需要清理的僵尸进程。${NC}"
    fi
}

# 4. 资源消耗排榜与服务注销 (升级版)
manage_proc() {
    echo -e "${YELLOW}CPU 占用最高的前 20 个进程及服务关联：${NC}"
    echo -e "----------------------------------------------------------------------"
    printf "%-6s %-8s %-8s %-15s %-20s\n" "序号" "PID" "CPU%" "命令" "关联服务"
    echo -e "----------------------------------------------------------------------"

    # 获取数据并排除脚本及系统工具进程
    mapfile -t proc_list < <(ps -eo pid,pcpu,comm --sort=-pcpu | grep -vE "PID|ps|grep|vps_fix" | head -n 20)

    declare -A svc_map
    declare -A pid_map
    declare -A name_map

    local count=1
    for line in "${proc_list[@]}"; do
        pid=$(echo $line | awk '{print $1}')
        cpu=$(echo $line | awk '{print $2}')
        comm=$(echo $line | awk '{print $3}')
        
        # 自动识别 Service
        unit=$(systemctl status $pid 2>/dev/null | grep -oP '(?<=● )[^ ]+' | head -n 1)
        if [ -z "$unit" ]; then unit=$(systemctl show -p Unit --value $pid 2>/dev/null); fi
        
        if [[ -z "$unit" || "$unit" == " " || "$unit" == "0" ]]; then
            display_svc="[非服务]"
            val_svc=""
        else
            display_svc="$unit"
            val_svc="$unit"
        fi

        printf "%-6s %-8s %-8s %-15s %-20s\n" "[$count]" "$pid" "$cpu" "$comm" "$display_svc"
        
        svc_map[$count]=$val_svc
        pid_map[$count]=$pid
        name_map[$count]=$comm
        ((count++))
    done

    echo -e "----------------------------------------------------------------------"
    echo -n "请输入要处理的序号 (多个用空格，例如: 1 3 5): "
    read choices
    
    if [ -z "$choices" ]; then return; fi

    for choice in $choices; do
        t_pid=${pid_map[$choice]}
        t_svc=${svc_map[$choice]}
        t_name=${name_map[$choice]}

        if [ -z "$t_pid" ]; then continue; fi

        echo -e "\n${BLUE}[处理 #$choice]${NC} 正在清理: $t_name ..."
        
        if [ -n "$t_svc" ]; then
            echo -e "  - 检测到服务: ${YELLOW}$t_svc${NC}，执行注销流程..."
            systemctl stop "$t_svc" 2>/dev/null
            systemctl disable "$t_svc" 2>/dev/null
            
            # 查找并删除服务文件
            svc_file=$(systemctl show -p FragmentPath "$t_svc" | cut -d'=' -f2)
            if [ -f "$svc_file" ]; then
                rm -f "$svc_file"
                echo -e "  - 已移除服务文件: $svc_file"
                systemctl daemon-reload
            fi
            pkill -9 -f "$t_name" 2>/dev/null
            echo -e "  ${GREEN}[成功] 服务已注销并停止。${NC}"
        else
            kill -9 "$t_pid" 2>/dev/null
            echo -e "  ${GREEN}[成功] 进程 $t_pid 已强制结束。${NC}"
        fi
    done
}

# 5. 动态限制 Docker 内存
limit_docker() {
    echo -e "${YELLOW}--- 正在获取运行中的容器 ---${NC}"
    mapfile -t containers < <(docker ps --format "{{.Names}}")
    
    if [ ${#containers[@]} -eq 0 ]; then
        echo -e "${RED}未发现运行中的 Docker 容器。${NC}"
        return
    fi

    echo -e "序号\t容器名称"
    for i in "${!containers[@]}"; do
        echo -e "$((i+1))\t${containers[$i]}"
    done

    echo -n "请输入要限制内存(200M)的容器序号: "
    read choice
    container_name=${containers[$((choice-1))]}

    if [ -n "$container_name" ]; then
        echo -e "${YELLOW}正在限制 $container_name 并重启...${NC}"
        docker update --memory 200m --memory-swap 400m "$container_name"
        docker restart "$container_name"
        echo -e "${GREEN}成功：$container_name 限制为 200M 物理内存。${NC}"
    else
        echo -e "${RED}输入无效。${NC}"
    fi
}

# 6. 彻底屏蔽系统服务
remove_bad_services() {
    echo -e "${YELLOW}提示：屏蔽服务（Mask）将导致其完全无法启动。${NC}"
    echo -n "请输入要屏蔽的服务名 (例如: gost clewdr apport，空格分隔): "
    read input_services
    
    if [ -z "$input_services" ]; then
        echo -e "${RED}未输入任何服务名，取消操作。${NC}"
        return
    fi

    for s in $input_services; do
        echo -e "${YELLOW}处理中: $s ...${NC}"
        systemctl stop "$s" 2>/dev/null
        systemctl disable "$s" 2>/dev/null
        systemctl mask "$s" 2>/dev/null
        echo -e "${GREEN}服务 $s 已被彻底锁死。${NC}"
    done
    systemctl daemon-reload
}

# 主循环
while true; do
    show_menu
    read -r opt
    case $opt in
        1) check_status ;;
        2) make_swap ;;
        3) kill_zombies ;;
        4) manage_proc ;;
        5) limit_docker ;;
        6) remove_bad_services ;;
        0) echo "退出中..."; exit 0 ;;
        *) echo -e "${RED}选择错误，请重试。${NC}" ;;
    esac
    echo -e "\n${BLUE}操作完成。按任意键返回菜单...${NC}"
    read -n 1
done
